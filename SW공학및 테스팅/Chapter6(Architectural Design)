< 6장 : Architectural Design >

 ** 목차
     - Architectural Design Decisions
     - Architectural Views
     - Architectural Patterns
     - Application Architectures
     
  ** Architectural Design ( 3~6 / 59 )
    
         >> Architecture Design의 경우, 여태까지 배웠던 것과 다르게, "특성"에 좀 많이 치우쳐 있다. 
             (기능적인 부분도 많지만, "특성"에 치우쳐져 있다)(같은 Method라도, 상황과 어떤 Architecture를 쓰느냐에 따라 바뀌는 것들이 많다.)
              ex ) 같은 아파트라도, 동서에서 만드는 아파트와 화성에서 만드는 아파트는 기본 Architecture가 다르다. 
                   똑같은 방 4개, 욕실 2개, 침실 1개라도, 집을 짓는 방식이 다르다. 자신들만의 강점을 내세워서 건축하는 경향이 있음.

         >> Architecture라는 개념 자체부터가 이미 "추상화"이다. 기본적으로, 만들고자 하는 시스템에 대한 많은 이해와 추상화가 이미 되어 있는
            상태에서 Architecture를 잘 만들수가 있는 것이다.
         >> 새로운 무엇인가를 만들려고 하는데, 잘 만들려다 보니 Architecture를 새로 만드는 것이다. 개발자들이 추상화할 때는, 멀리서 보았을 때
            "대충 이렇게 했구나~ 이것 하면 되겠네!" 하고 추상화를 완료하지만, 실상 개발을 하기 위해 들여다보면 , 
            멀리서는 보이지 못했던, 실제 알수 없었던 것들이 굉장히 많이 산재해 있다는 것을 깨닫게 된다. (물론 경험으로도 해결 가능하다)
         >> 그렇기에 Architecture가 굉장히 중요하다!

         >> 이 Architecture를 잘 짤것은 아니고, 이미 잘 만들어져 있는 Architecture를 가져와 쓰면 된다. 
         >> 물론 Architecture마다 장단점이 있다! 
         >> 요즘은 Google, Amazon 같은 곳에서 다 오픈한다! 근데 이것들을 잘 쓰려면, 해당 회사에서 달아놓은 설명들을 잘 보고 쓰는것이 좋다.
             (어떤 이유 때문에 만들어진 Architecture이다!) 
           
                -> 그렇기에, 그 Architecture의 철학을 잘 따라가야 한다! Architecture에는 어떠어떠한 것들을 고려해서 만들어졌고, 이런저런 일을
                   할 수 있다는 설명이 다 있다. 무조건 있다! 프로그램의 뼈대가 되는 애이기 때문에, 설명서를 반드시 볼것!
 
     *** Architectural Design (3/59 ~ 10/59 사이의 녹음이 일부 누락됨)
 
 ** Architectural Design Decision   (11/59 부터 시작함)
         >> Generation Architecture가 있는가? (일반적으로 정해진 Architecture 있으면 갖다쓰면 될 것이다)
         >> 서비스가 한 개의 환경에서 돌아가는가, 아니면 여러 환경에서 동작해야 하는가?
                -> 여러 군데에서 동작해야 하는것은, 한 군데에서 동작하는 것과 비교해서, 만들어야 되는 Architecture가 다르다!
                -> 미리 고려하여, 여러 군데에서 동작하는 여러 개의 코어가 있어야 하고, 이 코어 간 통신하는 Architecture가 반드시 필요하다.
                    (ex: (카카오톡) Android, IOS, 컴퓨터는 다 당연히 Architecture가 다를 것이고, 이 코어들 간에 통신하는 Architecture가
                         필요할 것이다.)

         >> 어떤 스타일의 Architecture인가?
         >> 어떤 "접근들"을 쓸 수 있는게 있는가? etc..
         >> 시스템 자체를 분리해서 만든다거나, 반대로 분리된 시스템을 합쳐서 만들수도 있음. Component도 , Sub-Component 같은 식으로 분리가
            가능. 다 상대적인 것이다.

         >> Delivery 할때 어떤 Architecture 조직이 좋은가?
         >> Architecture의 Documentation은 어떻게 하는 것이 좋은가? (많이 쓰이는 Diagram들이 있다!)

         >> 요런 것들을 정해야 한다!

     
     *** Architecture Reuse
     
         >> Architecture Reuse는 할 필요가 있고, 할수 있게끔 하는것이 좋다. 
         >> 어떤 공통된 시스템이 있으면( ex : 쇼핑몰 ), 다들 비슷한 구조를 가진다.
                -> ex : A 쇼핑몰과 B 쇼핑몰은, 물건을 구매하는 루틴 자체가 크게 차이가 나지 않는다!
                -> 개중에서도, 가장 선도하게 되는 Architecture들을 다들 따라간다.
                -> 물론 큰 틀에서는 대부분 비슷하겠지만, 소분류로 보았을 때는 그 분야마다 조금씩 느낌이 다를 것이다.
                    (그럴때는 약간씩 Architecture가 차이난다)
                    
         >> Product Line도 핵심 Architecture에 따라서 조금씩 달라진다.      
         >> 보통 이러한 Architecture들을, Style, 혹은 Pattern 이라는 말로 많이 표현을 한다! 
               (혹시 Java Design Pattern도...?!! 생각해보니까 그런 자바 디자인패턴도 결국 Architecture임)
              

     *** Architecture and System Characteristics
         >> Architecture에서 고려해야 할 사항 : Performance, Security, Safety, Availability, Maintainability
         >> 앞 단원에서 나왔던 System Non-Functionality Requirement랑도 연관이 된다.
         >> Architecture에서 보아야 할 내용들은, 주로 System Requirement에서 Non-Functional Requirement에 해당하는 것들이 많다.
         
         >> 그래서 개발 초기에 Architecture에 대한 이야기가 나올수밖에 없다. 만약에 Architecture 이야기가 뒤에 나오면,
            Non-Functional을 다 정해버렸으니, Architecture는 그 Non-Functioanl에 맞춰서 갈수밖에 없다. 심지어 Non-Functioanl에 
            안맞는 Architecture를 쓰면 안되는 것이다. 
         >> 그래서 Architecture를 정해 놓고 이야기하는 것이 조금 더 좋다!!
         
         >> Non-Functional Requirement 가 안맞으면, 싹 새로 엎어야 하는 예시! - Socket 통신 vs TCP-IP 통신
                -> 이미 서버구조를 Sub-Client 구조로 다 만들어 놓았는데(서버는 1개), 만약 서버가 여러 개가 되어야 할 수도 있으면
                   서비스 자체를 다르게 해야 함. 이럴 때는 Security도, Performance도 다 연관이 된다. 
                
                -> 이러한 Non-Functional한 내용들이 Architecture에 다 연관이 되어 있기 때문에, 미리 큰 틀에 대해서 정해놓지 않으면
                   뒤로 갈수록 점점 힘들어지는 것이다. 
                -> Architecture가 안 잡혀 있으면, if문 안쓰고 오로지 switch 문 만으로 조건 다 해결하세요! 하는 것과 비슷한 상황이
                   된다. Architecture를 잘못 선택해도 이와 같은 말도안되는 상황이 벌어질 수 있다.
                   
                   
 ** Architectural Views                   
         
         >> Architecture에서는 크게 4가지 관점으로 많이 이야기한다. (Logical View / Physical View / Development View / Process View)         
         
         >> 한 건축물만 하더라도, 보는 시야(View Point)에 따라서 다 다르게 보인다.
                -> 사람은 자기 시야안에서, 도는 서 있는 위치에 따라 똑같은 대상을 바라보더라도 다르게 보인다. 
                -> 심지어 같은 View Point를 가지고 있더라도, 그 사람의 사고방식에 따라 그 물체를 바라보게 된다.
                -> 심지어 해석하는 방식, 받아들이는 방식에 따라 해석도 다 달라질 것이다.
                
                -> Architecture를 볼 때도 이러한 관점들을 가지고, 여러 가지 관점(View Poin)로 봐야 한다!
                
         >> 관점 1. Physical View   
                -> 물리적인 관점. 어떻게 System이 생겨먹었는지, 시스템이 이렇고 저렇고 등등을 많이 고민해야 함.
                
         >> 관점 2. Logical View
                -> 어떠한 방식으로 동작할 것인가? 어떠한 형태로 데이터를 주고받는지, 어떻게 움직이는지 보는 것.
         
         >> 관점 3. Development View
                -> 개발하기 위해서는, 어떠한 Architecture를 가져갈 것인가? 개발을 쉽게하던지, 검증을 쉽게하던지, 개발을 빠르게하던지
                   등의 이유가 있을 것임. 
                   
         >> 관점 4. Process View
                -> 어떠한 절차로 처리되는 시스템을 만들 것인지?
                
         >> 기본적으로 Architecture에 대한 관점을 이러한 4가지 포인트로 많이들 이야기하지만, 사실 이 4가지 말고도 더 많은
            관점들이 있다. View Point는 말 그대로 "관점" 이기 때문에, 어떤 대상을 바라보느냐에 따라 다 달라지는 것이다.
         >> 꼭 이게 아니더라도, 다른 관점이 존재할 수 있다. 하지만, 대체로 이런 관점에서 Architecture를 바라본다는 것이다.
         
     *** 4+1 View Model of Software Architecture
         >> 크게 여러 가지 형태로 볼수 있다는 의미로, 4+1 View Model이라고 이야기함. 
               (위의 4개 + "User Senario" or "Use Case" )
         >> Requirement 짤때의 그런 관점 + User Stroy를 같이 보자!
         >> Logical View : Object를 추상화하는 것. 
               ex) 쇼핑몰에서의 회원, 관리자
                -> 회원관리, 판매물품관리, 결제내역관리, 결제기, 판매데스크 등 쇼핑몰 안에는 논리적으로 이런 것들이 있을 수 있다. 
                -> 이런 것 하나하나를 추상화하는 과정이 있어야 한다. (대체적으로 각 Object에서 어떤 일이 벌어지는지)

         >> Process View : 사용자가 해당 시스템을 사용하기 위해서 어떤 프로세스를 거쳐야 하는지?! ( Interaction 으로 이야기함 )
                -> 어떠한 절차에 따라서, 시스템이 어떻게 동작하는지
                -> 서비스가 제공되는 것들에 대한 내용에 관한 프로세스
            
         >> Development View : 클래스 단위나, 컴포넌트 단위의 Sub-System으로 쪼개는 것이다. 그런 관점에서 굵직굵직하게 Architecture
                               를 설계하는 것.
                               
         >> Physical View : 하드웨어, 소프트웨어 등이(System)이 어떻게 갖춰질 것인가?
         
                -> 대형 서버를 살것이라면, 하나만 살 것인지? 아니면 분산 서버로 해서 여기저기 두고, 사용자에게는 Cloud처럼 보이게 할
                   것인지? 웹 클라우드에 서버를 올릴 것인지? 등등
                        
         >> + 1 : 관련된 Use Case나 Senario
         
     *** Representing Architectural Views
         >> 이런 Architectural View는 UML(Unified Modeling Language)로 이해할 수 있다. 개발 쪽에서는 Diagram처럼 많이 쓰인다. 
         
         
 ** Architectural Patterns
         
         >> Architecture도 패턴들이 많이 있다. 
               ex) 웹 서비스에서의 MVC Pattern(Model, View, Controller)
                -> M (Model) : 원천 데이터를 이야기함 
                -> V (View) : 어떻게 사용자에게 정보를 줄 것인가? 
                -> C (Controller) : 알고리즘과 같이, 정보를 처리하는 Controller
                
                
     *** 웹 브라우저 상에서의 MVC : 
                -> 사용자는 웹 브라우저 상에서 "클릭"을 한다. 그럼 서버로 Request 보내는 것임. 
                -> 사용자가 원하는 것은, 서버로부터 어떠한 데이터를 받는 것이다. 그러면 서버는 그 Request에 대한 View를 준다.
                (사용자가 보는 화면은 다 View이다!)
                -> 만약 사용자가 로그인을 하면, 입력을 받아서 Controller가 처리해야 함. 입력에 따라 여러가지 처리를 통해
                   결과를 도출해 내는 애가 Controller이다. 
                -> Controller가 값을 return 하면, View 단에서 그 정보를 가공해서 사용자에게 다시 보여주는 것이다.
                -> Model은, 정보를 저장하고 내보내는 애들이다. 
                
         >> 각각의 애들이(M,V,C 같이), 서로 섞여서 뒤죽박죽 되지 않고 따로따로 할 일을 제대로 하는 관점이 Architecture이라고 
            생각하면 된다. 유지보수할 때도, 출력이 문제가 되면 View 단에 가서 처리하듯이!
         >> 이런 패턴이 있으면, 프로그램이 정말 쉽게 구조가 잘 잡혀간다!    
         
         
     *** The Organization of the MVC
     
         >> Model
                -> Encapsulation : 데이터를 있는 그대로가 아니라 한번 가공할 수 있다. 
                 ex) 은행 담보에서, 1000단위나 10000원 단위 아래는 안 보여주는 등. 한번 가공할 수 있음.
         
         >> Controller
         >> View
         
     *** Layered Architecture
         >> 인접 Layer 간에 데이터를 주고받는다. OS에서 바로 UI에게 데이터를 주고받거나 하지 못한다. (무조건 위아래로밖에 못 움직임)
         >> 크게 4개의 Layer가, 계층적으로 존재함. (보안 레이어는 가장 위나, 가장 아래, 아니면 전 계층에 분포)
         
         
     *** Repository Architecture 
         >> 어떤 Repository를 가지고 정보를 공유하는 것. 
         >> 큰 분량의 정보를 어디에 넣어두고, 처리하고, 보관하며, 공유하는 것.
         
     *** Client-Server Architecture
         >> Client와 Server의 역할이 정확히 구분되어 있다!
         >> Client : 고객
         >> Server : 서버(서비스를 제공하는 사람)
               -> 클라이언트가 무엇인가를 요청하기 전까지, 서버는 아무것도 하면 안된다.
         
         >> 웹 서비스는 대부분 다 Client-Server Architecture를 따른다. // 중간고사 범위
         
         
         
