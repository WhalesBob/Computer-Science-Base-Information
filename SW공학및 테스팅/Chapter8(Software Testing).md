# Chapter 8. Software Testing

## Topics Covered

+ Development Testing
+ Test-Driven Development
+ Release Testing
+ User Testing

### Program Testing

+ Testing 이란 무엇인가? 
  - Program Defect(결함) 찾기!
  - 프로그램을 만들었으면, 의도한 대로 잘 동작하는지 확인하기
+ 인위적인 Data로 테스트를 한다!
  - 물론 실제 데이터로 할 수도 있음. 하지만 그게 실제 데이터라 할지라도, 동작하면서 나오는 데이터가 아니다 보니 진짜 "실제 데이터"는 아니다!
  - 실제 데이터를 다시 가져와서 넣는것 자체가 이미 인위적인 데이터이다.(이미 한차례 가공이 된 것임)

+ Error 결과 확인하고 고치기
+ Non-Functional 적인 부분 확인하기. 여기서 Non-Functional 만족하지 못하면, 잘못된 것이라고 인식을 한다.
+ Testing을 했다고 해서, Error 가 없다는 것을 완전히 보증할 수는 없다. 에러가 있는데 못찾은 것일수도 있음.
+ 테스팅한 부분만 에러가 없다는 것을 보증할 수는 있어도, 나머지 테스팅이 안된 부분은 보장할 수 없는 것이다.
  - 모든 경우에 대해서 다 테스팅 해볼수 있다면, 에러가 아예 없다는 것을 보증할 수 있지만, 현실적으로 불가능하다. 

+ 크게 나누면, Verification & Validation 두개로 나눌 수 있다. 
  - Verification : 스펙에 적혀있는 의도대로 되어 있는지?(스펙에 적혀져 있는 대로 되어 있는지?)
  - Validation : 유저가 의도하는 대로 만들어져있는지?

+ Testing하는 목적 : 
  - Developer와 Customer에게 보여주기 위한 목적이 있다.
  - Testing이 잘 수행되면, 해당 Software가 잘 만들어졌고, Requirement를 달성했다고 볼 수 있다. 
  - <strong> 1. 앞서 User Story, User Senario가 있었고, 그것을 가지고 System Requirement를 뽑아낼 수 있었다. 그럼 그 Requirement가 잘 되는지 보여주어야 테스트가 끝나는 것이다.(Validation)</strong>
  - <strong> 2. 스펙과 맞지 않는 이상한 짓을 하는지 여부를 체크하는 것. (Defect 체크) </strong>
  - Validation 이 되기 전에, Verification을 체크하지 않으면 이후 Validation이 될 수가 없다.
    - 애초에 스펙이 다 만족이 되지 않으면, Validation에서 통과가 될 리가 없다. 
    - Validation은, Verification 이후 유저가 직접 눌러보면서 확인하면 그것이 Validation이다.
  - 일단 먼저, 맨날 쓰던 대로 써보고 그것부터 다 만족이 되어야, 그다음에 Error를 찾는것이 의미가 있다.
    - 애시당초에 맨날 쓰던대로도 충족을 못하는데 Error를 찾는게 무슨 의미가 있을까?
  
### Validation & Defect Testing
  
+ Validation Testing : 개발자와 Customer가 만나서 스펙에 따라 다 짜여졌는지 확인하는 것.
+ Defect Testing : Defect, Error, Failure 등을 찾아내는 것.
  
### Testing Process Goals
+ 기본적으로 원하는 Input을 넣어보고, 원했던 Output이 잘 나오는지 부터 테스트해보는 것이다.
    - Black-box Testing : 시스템 내부는 아무것도 모르는 상태로, 입력을 줬을 때 출력이 제대로 나오는지 확인하는 방식.

### Verification vs Validation 

+ Verification : Product를 만들 때 올바르게 만들었는가?
  - 만들어야 하는 것을 만들었는가?
  - 스펙에 맞게 만들었는가?

+ Validation : 유저가 원하는 대로 만들었는가? 유저가 실제로 요구하는 것이 무엇인가?

+ Verification 과 Validation 중 하나라도 빠지면 안된다. 
+ Software 목적/유저가 바라는 사항/Marketing 환경 등은 Validation 에 속한다
  - 저런 것들은 Requirement랑은 관계없는 경우가 많다.
  - 꼭 보고 싶었으면 Requirement에 집어넣었을 수도 있지만, 대체로 집어넣을 수 없는 것들이 많다. 

### Inspection(검사,점검) & Testing

+ 흔히 Review라고 많이 이야기한다. 
+ Inspection : Requirement 에 있는 애들과 소스코드를 비교하며, 맞는지 아닌지 "검사"할 수도 있다. (정적 분석, Static Verification 이라고도 부름)
  - 문서만, 코드만 봐도 당장 앞뒤가 안맞는 부분들, 모순되는 부분들이 나올 수 있다! 그런것들을 찾는 것이다.
  - 동작시켜서 찾는것보다 훨씬 더빨리 찾을 것이다. 
  - Tool based document : IDE에서 제공되는 Tool에서 경고 뜨는것들로 충분히 찾을 수 있다!
  - Inspection 할때는, 스펙, Architecture, 설계, Schema 등 다 "검사"할 수 있다.
  - 프로그램이 개발 안된 상태에서도 할 수 있다.
  - 동작시켜서 보는것만큼 디테일하게 볼 수는 없다. 동작시켜서 보는것만큼 더 많은 것을 할 수는 없다. 대신, 전 단계에 걸쳐서 할 수 있다.
  - 실행하지 않고서도 볼 수 있다

+ Testing : 실제로 Product를 돌려보면서 찾을 수도 있다. (동적 분석, Dynamic Verification) 
  - 실행시키면서 잘 동작하는지 보는 것을 동적 분석이라고 많이 이야기한다. 
  - 결과물이 있어야만 테스팅할 수 있다.

+ 둘다 해도 못 찾는 에러가 나타날 수 있다. 그러므로, 최소한 Inspection, Testing 둘 다 해보면서 에러를 찾아야만 한다.
+ V&V(Verification & Validation) Process 안에서, 두개 다 할 수 있다. 
  - Inspection 같은 경우, Non-Functional Check 하는 것이 불가능하다. 
  - Performance, Usabilty, 기타등등 특성에 관련된 것들은 Inspection 으로 파악하는 것이 불가능하다. 직접 해봐야 알 수 있다.
  - 스펙 문서만 보고 파악하는 것이기 때문에, 유저의 요구사항은 확인할 수 없다.(문서도, User Requirement가 한번 거쳐서 온 것임)
  - 동적 테스팅할 때는, 유저가 옆에서 보고 있으니 유저의 실제 요구사항을 반영할 수 있다.

### A model of the software testing process

<img src = "Ch8_1.png" />

+ Test Case : Test Input과 기대값(expect value)가 합쳐진 것.
  - 설계할 때 Requirement 보고 이야기할 때, 어떤 것을 눌렀을 때 무엇이 나와야 하는지 같은 것들.
  - 처음에 기대했던 것과, 나중에 나오는 것을 비교하면서 테스팅을 진행할 수 있다.
+ Test Data : Test에서의 Input
+ Test Result : Test에서의 Output
+ Test Report : 몇개 통과했는지, 몇개 Fail났는지 나오는 Report

### Stages of Testing(테스팅 단계)

+ Development Testing(개발 테스팅)
  - 시스템 개발할 때, 개발 중간에 이루어지는 여러 가지 테스팅. 
+ Release Testing
  - 개발이 끝났고, 출시하려고 하는 프로그램을 다른 테스트 팀(QA 팀)에서 테스트해 보는 것.
+ User Testing
  - 실제 사용자가 테스팅하는 것. 결국 Release Testing하는 사람도 개발자임. 실제 사용할 사용자가 할때는 또 다르게 될 수도 있다.
  - ex) 핸드폰을 샀는데, 기능 다 매장에서는 잘 되었는데 집에서는 안되는 경우, 와이파이 표시는 떠있는데 실제로는 데이터를 소모하는 경우 등이 있을 수 있다.
  - 유저가 사용하는 환경에서 사용해 보아야 한다. 


## Development Testing

+ 개발하는 중간에 일어나는 Testing. 개발자가 일반적으로 이야기하는 Testing은 Development Testing이다. 
+ 개발팀이 아닌 사람은, 이 과정을 개발 과정의 일부로 생각한다. 그래서 많은 사람이 아는 Testing은, Development Testing 이후이다.
  - Development Testing 과정에서, 오류가 발견되었다면 Debugging 함. 이것은 개발이라고 볼 수 있음. 계속 코드 고치기 반복하니까!
  - 큰 틀에서 보았을 때는, 개발이다 라고 볼수 있는 것이다. 
  - 심지어 Requirement 만들 때도, Conflict가 일어나니까 계속 고쳐나가는 측면에서는 Debugging이라고 볼 수도 있는 것이다.
  - 개발 과정중에서 하는 검증인데, 마땅한 용어가 없으니까 Testing이라고 한다고 한다. 
  - 말 그대로, Testing이라는 것 자체가 "테스트하는 행위"를 이야기하는 것임. 그냥 이런 행위적인 것들이 들어가면 Testing이라고 이야기하는 것.

+ Unit Testing / Component Testing / System Testing 이런 것들이 있을 수 있다.
+ Unit Testing 
  - 단위 테스팅. 우리가 Software Engineering 할때 가장 기본이 되는 개념은 "객체지향" 이고, 그 안에서 가장 작은 단위는 "객체" 이다.
  - Unit(객체) 를 Testing 하는것을 보고 단위 테스팅, Unit Testing이라고 할 수 있다. 
  - Unit Testing의 가장 큰 목적 : Functionality
    - 객체 안에 여러 개의 Method가 있다. 
    - 객체 안에 어떤 값들도 확인하고, Method도 다 잘 동작하는지 확인해야 한다. 
  
  - 객체 만으로 테스팅을 다 하는 것! 객체 단위에서 쪼갤수없는 곳까지 가서, 그 Scale에서 Testing 진행하는 것이다. 
  - 객체, 속성값, 메소드 Level에서 테스팅을 진행하는 것이다. 
  - 만약, Static Class라서 객체 내 속성값이 없는 경우가 있다.(여기서 속성값 : 각 객체가 지니고 있는 고유 값)
    - 메소드만 있다고 가정할 수 있다. 이럴 때는 각 attribute(속성값)을 볼 필요가 없다. 

  - 객체가 Method가 없는 객체일 수 있다! 추상화 클래스라서 속성값만 있다면, 어떻게든 해당 속성값이 변하는 것만 확인하면 된다. 

<strong> 원래는 어떤 객체가 있다 치면은, 다른 외부 Component에서 어떤 Interaction 이 일어나든, 해당 객체에 대한 속성값까지 다 바뀌는 것을 확인해야 한다. Unit Testing 단계에서 확인할 수는 없는 부분이라 할지라도, 원래는 그런것까지 다 체크를 해야 한다는 사실은 알고, 메소드를 테스팅할 때도 그런 부분을 감안해서 개발하고 테스팅해야 한다. </strong>

+ Component Testing
  - Component 단위를 Testing하는 것. Integration Testing이라고도 불린다. 
  - Object보다 더 큰 단계. 여러 개의 Object가 모여있는 것을 보고 Component라고 부른다. 
  - Component는, 또 다른 이름으로 SubSystem이라고도 부를 수 있다. System과 Object 중간의 어딘가에서 테스팅 한다고 생각하면 된다.
  - Component는, 또 다른 Component로도 만들 수 있다. 
  - 객체가 여러 개 있을 것인데, 객체 간 서로 취급하는 데이터가 다 다르고 약속된 것이 다 다르다. 이런 부분을 통합해서 맞추어 주며, 테스팅을 진행하는 것을 Component Testing(Intergration Testing) 이라고 한다. 
  - 하나의 Component로써 무엇인가를 했을 때 그것이 잘 동작하는지 아닌지를 확인하는 것이다. 
  - Component들을 굳이 Sub-System이라고 부르는 이유는, 이것들도 하나의 System으로써 동작할 수 있기 때문이다. 이것을 이미 다른데 갖다 붙이면, 다른 시스템에서 충분히 사용할 수 있을 저옫의 어떤 Level 이 된다. 그래서 Component 단위의 Testing에서도 웬만큼 테스팅이 잘 이루어져야 한다.
 
+ Interface Testing
  - 어떤 데이터를 주면, 어떤 데이터를 다시 돌려주는지의 관점에 따라 행해지는 Testing.
  - 어떤 Input을 줬을 때, 해당 되는 Output을 하나하나 보는 것이 Interface Testing이다. 
  - 

#### 개발할 때는 Top-Down으로 가면 좋지만, 테스팅할 때는 Bottom-Up으로 가는것이 좋다. 
+ 설계할 때는 복잡하게 생각할 것 없이 짜면 되지만, 설계할 때는 아래에서부터 위로 하나씩 테스팅해가면서 진행해야 한다. 
+ 아래에서 위로 진행했으면, 아래에 있는 것들이 모두 테스팅 완료 되었으니, 위에서는 단순히 연결부위 테스팅을 진행하면 된다. 
+ 테스팅했을 때 문제가 생기면, 연결부위에 문제가 생겼을 경우나, 아니면 아랫 부분에서 테스팅에 누락이 발생한 것이다. 
+ 이렇게 진행하다보면 최종적으로 System Testing까지 이루어지게 된다. 
  - System Testing까지 진행되면, 대체로 기능적인 부분은 잘 동작한다고 봐야한다. 
  - System Testing에서는, Component 간의 Interaction을 주로 테스팅한다. 

### Test Coverage

+ 테스트를 어디까지 할 것인가에 대한 이야기이다.
+ Coverage 종류는 여러가지 있음
  - Statement Coverage : 한줄한줄 문장을 하나하나 실행하는 것임. 모든 문장을 실행해야 Test Coverage 가 100% 만족하는 것이다. 
  - Decision Coverage : 모든 문장을 다 실행해볼 필요가 없다. 단순히 분기(If문) 만 다 통과하면 된다는 주의
  - Class의 Test Coverage :  모든 Operation을 다 거쳐야 한다.(Class 내 모든 Method를 다 Testing해야 한다.)
    - 똑같은 Method라도 해당 객체의 Attribute(속성값)이 다르면 동작하는 내용이 달라질 수 있다. 
    - ex) Active / Inactive 에 따라, 같은 Method라도 동작하는 내용이 다를 것이다. 
    - 이런 State도 바꿔 가면서 동작시켜 봐야 한다. 

+ 상속이 개발하거나 설계할때는 되게 좋지만, Test할 때는 대단히 어려워진다. 
  - 추상 클래스 테스트할려면, 아래 자식 클래스 Testing도 다 해야 한다. 부모는 자식에 다 들어갈 수 있으니
  - 객체에 대한 Unit Testing이라고 하고 있는데, 실제로는 "Unit" Testing이 안 되는 것이다. 

+ 테스팅할 때 정답은 없지만, 테스트는 최대한 많이 해보는것이 제일 좋다. 해보는 케이스가 많으면, 해당 프로그램에서의 "정확도" 가 올라가게 된다.
+ 하지만 테스트에서는 무조건 중요한, Critical 한 부분부터 내려가서 점차적으로 중요도가 떨어지는 애들 방향으로 하는것이 좋다. 

### Automated Testing
+ Setup Part : 딱 함수를 테스트하기 전 Pre-Condition으로 만들어 주는 Part. 
  - Setup Part는 고정적이다. 해당 함수를 실행하기 위해서는 그 함수가 실행되는 조건이 있을 것이다. 그 조건으로 만들어 놓고 실행하는 것임.
  - 조건이 없으면 무작위로 실행되기도 한다. Setup Part를 안 쓸수도 있고, Random하게 임의의 값으로 줄 수도 있을 것이다. 
+ Call Part : 실제로 테스트하고자 하는 Part. Test Case를 넣어서 실행시키는 Part.
+ Assertion Part : Call Part에서 나온 내용을 가지고 참/거짓 같은 내용을 바탕으로 후처리하는 Part. 
  - Call Part에 Test Case를 넣어보고, 기대값과 실제 Output을 비교해서 같으면 True, 아니면 False

+ Setup Part는 없을 수 있지만, Call/Assertion Part는 대부분 있다. 

### Choosing Unit Test Cases

+ 어떤 Test Case를 가지고 갈것인지 선택해야 한다!
  - 1~10까지 케이스가 있다고 하면, 다 넣으면 좋다. 
  - 자동화로 하면 그것이 쉬운데, 수동으로 10개, 100개 다 테스트 케이스를 넣어서 테스팅 해보려면 상당히 어렵다.
+ 그럼 그 중에 어떤 것을 해야 하는가?
  1. Normal Operation : 이미 스펙 상 정의된 것들을 가지고 테스트 케이스를 만들어서 넣어 보는 것.
  2. Abnormal Operation : 스펙에 없는 희한한 동작을 해보는 것. 창의적으로 해보는 것.
    - ex : 0 이상의 자연수라서, 0 이하의 숫자는 예외처리를 해 두었는데, 1.5같은 실수를 넣으면? 에러가 날 수 있다.
    - 물론, 여기서 1.5를 넣으면 1로 처리될 수 있으니, 잘못된 입력값이라고 처리를 해 줘야 할 것이다. 1.5가 들어갔을 경우 계산을 멈추게끔 동작시켜야 한다. 
    - 1.5를 넣어서 동작하는것은 Spec 상에 정의된 내용이 아니니 Abnormal behavior라고 말할 수 있다.

### Test Strategies
+ Partitioning Strategy : 
  - 어떻게 Partitioning을 하는가? : Equivalent Partitioning을 하거나, GuideLine Based Testing 진행한다.

### Partition Strategy
+ Partitioning Testing 같은 경우 주로, Input이 100개 있다면, 다 넣어서 테스팅하는 것이 제일 정확하다. 
+ 하지만, 다 하기 너무 힘들어서 Partitioning을 한다. 
+ 데이터 특성을 봐 가면서 조각내면 된다. 
    - ex) 0~20 , 21~40 , 41~60 , 61~80 , 81~100 이렇게 Partitioning 했다면, 각 파트에서 하나씩 집어넣으면서 테스팅하면 될 것이다. 
    - 동작하는지를 보려고 하는 것이니, Input을 그에 맞춰서 집어넣어 보는것을 Partitioning 이라고 한다. 
+ 칸막이 치고, 그 대표값 하나씩 넣어보면 될 것이다. 다른 것들은 넣어볼 필요가 없는 것이다. 

+ 보통 Equivalence Partitioning(균등분할)을 한다. 
   - 1이라는 데이터, 2라는 데이터 가 다 균등, 동등 하다는 이야기임. 
    - 물론 이 "동등" 의 기준은 다 다르다. 코드나 시스템, 스펙에 따라 다를 것이다.
    - 이 "같은" 기준의 집단을 Equivalence Class라고 이야기한다. 
    - 인공지능에서도 이렇게 클래스를 나누어 데이터를 학습시키고 하는 것임. Partition 별로 데이터 Input을 뽑아내어 처리한다. 
    - 함수로 치면, 정의역, 공역에 있는 무엇인가 중 하나가 선택되어 짝지어지는 것임(Test Case로)

+ 보통 경계값에서 문제가 많이 발생한다. 
+ 보통 평균값, 경계값과 평균값 중간 두개, 그리고 경계값으로 테스팅 진행한다. 
  - 경계값을 전후로 해서 하나씩, 그리고 중간에 두개, 그리고 평균값으로 많이 진행하면 맞다. 
  - Equirvalence Partitioning을 이미 했기 때문에, 2개를 더 해주든 3개를 해주든 의미없다. 똑같다. 아니라면 Partitioning 잘못한것임.
  
### Testing GuideLines(GuideLine Based Testing)
+ "가이드" 를 주는 것이다. 
+ 이미 개발해보았던 사람이나, 그 전에 테스팅해 보았던 사람이 경험이 되게 풍부하다고 한다면, 그사람 말 믿고 그사람이 쥐여주는 대로 테스팅 해 보아도 좋을 것이다. 
+ 하지만, 주어진 가이드라인이 부정확할 수 있다는 사실을 언제나 배제해서는 안된다. 

+ 가이드라인 테스팅 같은 경우 어떤 테스팅을 해주는가?
  - 일부러 시스템이 에러를 만들어내게끔 하는 상황에서 테스팅해보는 것.(예외처리가 잘 되어 있는지 확인하기 위해)
  - 스펙에 있는 애들은 잘 되게끔 개발해 두었을 것이다.
  - 하지만, 숨어 있는 Requirement나 Senario에서 나오는 에러들은 스펙에 없는 애들일 것이다. 
  - 이런 것들에 대한 예외처리가 잘 되어 있는지도 가이드라인에 나오는 Test-Case로 진행해 보면 파악할 수 있을 것이다. 
    - ex) 일부러 StackOverFlowException 이 발생하는 시나리오 대로 테스팅해보는 것.
    - 일부러 배열이나 리스트가 넘치게 해 보는것.
    - 일부러 같은 값만 계속 집어넣어 보는것(그럴리가 잘 없음)
    - 우리가 알고 있는 Output이 아닌, 다른 Output Data가 나왔을 때 어떻게 대처되는지 보기
    - 너무 크거나 너무 작은 값으로 나오게끔 계산 강제해 보기.
    - 이런 테스트 케이스를 찾아내는 것도 개발자의 능력이다. 이러한 에러 하나 때문에 시간을 엄청나게 잡아먹게 되고, 이런것들이 다 돈으로 귀결되는 내용이 되어 버린다. 이런 내용들을 이미 다 알고 있어서 객체에 적용한다면, 프로그램이 정말 짜기 쉬워지고 시간을 아끼게 되며, 이것이 다 프로그래밍 실력이 되어 버린다. 
    

### Component Testing
+ Functionality가 기본! Sub-System으로써 통신하려면 일단 기본적으로 Functional Requirement는 다 짜놨어야 함. 
  - 애초에 그렇게 동작해야 하는 것이 기본이다. 기능을 수행할 수 있어야 그 다음에 다른 이야기를 하는 것임.
  - 객체만으로는 어떤 "기능"을 수행하기에는 대단히 약하다. 객체 하나가 어떤 기능을 수행할 수 있다는 말은, 그냥 설계 잘못했다는 말임.
    - ex ) MVC 패턴이 있다면, M/V/C에 해당하는 애들이 전부다 객체로 별도로 존재함.
    - 당연히 각각이 기능을 수행할 수가 없다!

  - 그래서 Component 단위에서는 "기능"에 초점을 맞춘 테스팅을 진행하게 된다. 
    - MVC 같은 경우, Controller가 Data 잘 가져오는지, View를 잘 보내주는지, View에서 잘 나타나는지 이런 것들을 Testing에서 보게 된다. 
    
    
### Interface Testing
+ 테스팅할 때는, 정상적인 데이터를 넣고, 정상적인 결과를 받아보는것이 당연한 일이 되어야 한다. 
+ 정상적인 것에서 벗어났을 때, 이상한 것을 한번 넣어보았을 때도 잘 동작하는지를 확인해야 한다. 
  - 애초에 정의역을 정수로 지정해두었지만, 그래도 한번 실수를 집어넣어 보는 것이다. 
  - 100% 정수만 집어넣어질 것이라는 보장이 없다. 
  - 여러 개가 섞이다 보면, 정수가 아니라 실수로 파라미터가 전달될 수 있는데 그런부분에서도 예외처리가 확실히 되어 있는지를 봐야 한다. 

+ Parameter Interface 같은 경우, 데이터 주고받을 때 Parameter 값도 봐야 함.
+ Shared Memory의 경우, (자바에서 Static 변수들) 다른 함수에서 같은 값을 참조하고 바꾸는 경우 의도한 대로 정확히 동작하고 있는지 확인해야 한다. 
+ 한 Interface를 여러 가지 SubSystem이 같이 쓰는 경우도 고려해 줘야 한다. 다른 System도 한번씩 고려사항에 넣어야 한다. 
+ 정상적인 데이터, 비정상적인 데이터를 나누어서 하나씩 집어넣어 봐야 한다.

+ Interface Testing 할 때는 여러 가지 위험들이 발생할 수 있다. 
  - Interface Misuse : C, C++, Java 같은 언어들에서, 순서에 맞지 않게 Parameter를 전달하는 경우 에러가 날 수 있다.(당연한거아닌가)
  - 
  - Interface Misunderstanding : 아예 함수나 인터페이스를 잘못 쓴 경우.
    - Function A를 써야 하는데 B를 쓴 경우. Function A에 정수를 넣어야 하는데 실수를 넣는 경우.
    - 잘 몰라서 잘못 쓰는 경우임.
    
  - Timing Errors : 해당 상태에 맞는 무엇인가가 들어가야 하는데, 그 상태에서 그에 맞는 것이 못 들어가면 생기는 에러. 타이밍에 맞게 들어가지 못해서 생기는 에러.
    - Data가 sensing되는 주기가 10분 단위라고 해보자. 10분단위로 상태가 바뀌는 것인데,  데이터를 가져오는 것이 20분에 들고 와야 하는데, 25분에 들고 오면 에러가 남.
    - 25분째에 그 데이터를 들고오는것이 아무런 소용이 없는 Case가 있을 수 있다.

### Interface Testing GuideLines (시험에 나올 확률 높음!)
+ Parameter를 Range의 극단으로 보냈을 때, 에러가 나지 않아야 함.(의도하는 대로 동작해야 함)
+ 포인터의 경우, 반드시 NullPointer를 넣어봐야 함.(항상 포인터나 시스템적인 이런 부분을 쓸때, Null인지 아닌지 항상 고려대상에 넣어야 하는 것도 다 이런 이유 때문이다.)
  - 특히 NullPointerException 때문에 Segmentation Fault가 많이 일어날 확률이 높다.
+ 일부러 에러를 만들게끔 설계해 보자!
+ Stress Testing 해보기!
  - ex) 시스템이 30분만 동작하면 되는데, 1시간 정도 동작시켜 보는것! 만약에 1시간이 지나도 안정적이라면, 잘 만든 제품이 될 것이다.
  - 30분 이상 절대 쓸일이 없는 것이라도, 2시간이 지나도 멀쩡하다고 한다면, 정말 잘 만든 것(오버스펙)
+ Shared Memory의 경우, 함수 실행 순서를 바꿔볼 것! 그래도 정상적으로 동작할 수 있는지 한번 체크해 볼 것! 

### System Testing
+ 개발의 실질적인 마지막 단계. 이것을 통과하면 목표한 개발을 거의 마쳤다고 볼 수 있다. 
+ Functionality 보다는 Non-Functional 에 해당하는 부분을 많이 본다. 
+ 정확한 시간에 정확히 동작하는지 봄.
  - 1초 안에 동작해야 한다고 했는데, 2초 안에 동작하면 안되는 것이다.
  - 당연히, 데이터가 잘 오는것은 이전에 검증을 다 마쳤을 것임. Component 단위에서는 잘 동작했던 것들이, 시스템을 합쳤을 때도 정상적으로 동작하는지 확인하는 것.
  - 당연히, 이럴때 처리하는 시간이 걸릴 것이고, 시간이 더 많이 걸리는 와중에도 Non-Functional한 시간적인 부분이 충족이 되는지는 봐야 한다. 
+ 비정상적인 상황에서도 잘 연결되거나 대처되는지 봄.

### System and Component Testing

+ 팀단위로 테스팅하는 경우가 많다. 혼자서 하기에는 양이 너무 많기 때문.
+ 세팅 등 사전작업이 많이 필요한 경우가 많다. 
+ 장비에 실어서 해 봐야 하는 상황도 있음. 개발 환경에서 할 수 없는 것들도 많이 해본다. 

### Use-Case Testing
+ System 단위의 기능들에서, Use-Case 단위의 큰 기능들을 위주로 테스팅해보면 될 것이다. 
+ Use-Case 안에는 Functionality, Non-Functionality 도 있을 것이다. 이런 것들을 다 테스트하면 된다!
+ 주로 Sequence Diagram으로도 많이 함. 하나의 기능을 상세화시켜서 볼 수 있다!
  - Test Case를 가지고 Sequence Diagram으로도 나타낼 수 있다. 
    - Use Case가 되게 추상적으로 적혀 있다 보니, Sequence Diagram으로 풀어내어 할 수도 있는 것이다. 

+ System Testing의 경우, 절대로 다 해보지 못한다!
    - Unit Testing의 경우, 마음먹으면 진짜 다 해볼 수 있다. 돈과 시간이 문제임. 
    - ex) 에어컨의 경우, 어디에 설치하는지, 어떤 환경에 설치해보는지 등을 싹 다 테스팅해볼 수는 없다.
    - 30분 돌려볼것인지, 2시간 돌려볼 것인지, 등 이런 시간적인 부분도 "모든 걸 다" 해볼 수는 없는 노릇이다.
    - 그래서 항상 테스팅할 때는 상한선을 정해 놓고 테스팅해야 한다. 상한선을 넘으면 "Stress Testing" 이 된다. 
    - 그럼 어떤것들은 꼭 해야 하냐?
      - 모든 System Function들은 한번씩은 다 해봐야 한다.
      - Function 의 조합들은 한번씩 해봐야 한다.(Integration Testing)
      - 모든 Function에 대해서, correct input과 incorrect input을 다 넣어보면서 테스트 해야 한다.


## Test-Driven Development

+ 테스트 기반의 개발이기 때문에, 테스팅을 고려해서 개발하는 방법이다. 
  - 시험이라고 보면, 공부한 내용들을 얼만큼 알고 있고, 어느 정도 수준이 되는지 알기 위해서 보통 시험을 치른다 
  - 근데 막상, 사람들은 시험을 잘 치기 위한 공부를 한다. 
  - 개발에서도 마찬가지! 시험칠 내용이 정해져 있으면, 시험에 나올 내용만 공부하면 성적이 잘 나올 것이다. 
  - 그래서 테스팅에 나올 내용들을 위주로 개발을 한다고 생각하면 될 것이다. 

+ TDD 에서는 inter-leaving(하나하나 와 동시에 의 어딘가?) 하게 testing과 개발이 같이 일어난다. 
  - 개발할 때, 우리가 개발하면서 대비하는 것 자체가 테스팅과 연관성을 지니고 개발이 진행된다 
  - 어떤것을 테스팅할 지 다 알면서 개발이 진행된다. 
  - 테스트를 하기 전에도, 개발의 어떤 요소들이 테스팅이 될지 이미 다 정해져 있는 것이다. 
  - ex ) 로그인을 할 때, 아이디를 영어로도, 숫자로도, 특수문자로도 해보면서 테스트를 수행한다고 정해져 있는 것이다. 
     - 만약 ID가 영어로만 쓰여져야 한다는 Criteria가 정해져 있다고 한다면, 그에 대비해서 그에 맞게끔만 코드를 짤 수도 있는 것이다. 
     - 이렇게 한다면, 테스트에서는 통과할 것임. 

  - TDD에서, Incremental Development 방식으로 코드를 짜게 되면, 테스트도 그에 따라서 진행이 되게 된다. 
     - A라는 단계에서 구현하고, A라는 단계에서 테스트를 진행을 하게 된다. 
     - 그 다음 단계로 가게 되면, 그 단계에서 구현되고 그에 맞게 테스트가 이루어진다. 
  
  - TDD에서는, 짠 것에 대해 테스팅 다 하고 넘어가야 하는 방법론이다. 
     - 원래같으면, A,B,C 이렇게 다 개발하고 한방에 테스팅하고 넘어갈 수도 있지만, TDD에서는 A 짜면 A 테스팅, B 짜고 B 테스팅, C 짜고 C 테스팅하는 방식으로 넘어간다 
  
  - TDD는 Agile 방법론에서 많이 쓰인다. WaterFall 에서는 테스팅이 맨 마지막에 이루어지기 때문에, TDD 방식대로 할 수 없다. 
    - Plan-Driven에서는 잘 쓰지는 않음. TDD는 Agile에 더 잘 어울린다. 

+ 1. 기능 정의가 되게 되면, 어떤 테스팅을 수행해야 할지 내용이 다 나오게 된다. 
  - 기능 명세가 나오게 되면, 명세 자체가 테스팅할 항목으로 탈바꿈될 수 있다.
  - 우리가 코드를 짤 수 있게끔 테스트 케이스의 형태로 작성이 되어야 한다. 
  - 그래서 개발해 보고, 실제로 수행해보는 것이다. 
  - 수행해 보고, 맞으면 다른 기능을 더 개발 진행하고, 실패하면 다시 고쳐서 테스팅해보는 것이다. 
  - 방법론 자체가 어렵지는 않다.
  
+ 2. TDD를 할 때는 Functionality에 대해서 먼저 정의를 하는데, 이때 최대한 잘게 잘라서 정의해야 한다. 
  - 큰 기능도, 작은 기능으로 쪼개야 하나하나를 테스팅 가능하다. 
  - ex) Use-Case에 작성해 놓은 로그인 기능이 있다고 하자. 
     - 로그인 기능도 어떻게 쪼개느냐에 따라 조금씩 달라질 수 있다. 
     - 사용자 종류가 10명(관리자, 판매자, 소비자, 중간유통업자, VIP 등)이 있다고 하면, 각 역할이 있는 유저별로 다 로그인을 해 봐야 하는 식으로 Test Case를 구성하고 테스트를 진행할 수 있다. (Partitioning)
     - 이렇게 작은 기능으로 Incremental하게 나눌 수 있다. 관리자로 먼저 로그인 구현하고, 소비자, 판매자로 로그인 구현하는 등 차근차근.
   - 작은 단위로 개발을 진행하고, 테스팅을 하면 더 기능이 정확해지는 것이다. 어느 부분에서 문제를 해결해야 하는지 문제를 좀 더 쉽게 파악할 수 있기 때문이다. 
  - 이렇게 작은 형태로 가게 되면, 이 애들을 테스트할 때는 비슷한 형태의 테스팅이 될 것이다. 큰 기능이 정해져 있으니, 세부기능 들어가는것은 작게작게 개발하고 테스팅할 수 있다. 
  - 똑같은 형태로 반복적으로 테스팅하는 것이다 보니, Automated Testing하기에도 쉽고, 굉장히 유리하다. 
  - test를 수행했을 때, 다른 test-case도 함께 구현해 주면 좋다!

  - 항상 새로운 테스트를 할 때는, 이전에 있던 기능들이 통과되어야 새로 할 수가 있다. 
    - 물론 뒤의 기능들이 앞의 기능과 독립적으로 이루어지는 경우도 있지만, 의존적인 경우도 있다. 
    - 그럼 앞에 것이 잘못되었다면, 뒤의 것은 당연히 안 되는 것임. 
    - 앞의 것에 의존적인 어떤 기능들이 있다면, 앞의 기능들이 제대로 수행되지 않았으면 뒤의 기능도 수행 불가하다. 
  - 꼭 굳이 이렇게 해야 된다는 것은 아니지만, 앞에 것을 완료하고 뒤의 것을 하는 것이 테스트에 조금 더 유리할 것이다.
  - functionality를 구현하고, test를 re-run 할 필요가 있다. (그렇기 때문에, 자동화할 필요 또한 있다.)
    - 구현하면서 side-effect가 발생할 수도 있음.
  - 이러한 테스트가 성공적으로 끝나게 되면, 다음 기능으로 넘어가서 진행하면 된다. 

### Benefits of Test-Driven Development

+ 이런것들이 이점이 있을 수 있다!
  - Code Coverage : 반드시 내가 짜는 코드에 대해서 적어도 한번씩은 수행해 보는 것
    - 실행된 적이 없는 코드가 존재하면, 코드를 잘못 짰거나, 테스트를 잘못하거나(테스트 케이스를 잘못 만들어냈거나) 둘중 하나이다. 

  - Regression Testing : 자동화까지 이루어졌다면, 순서대로 한번, 두번, 세번 계속 테스팅이 반복된다. 
    -  할때마다 앞의 코드를 다시 테스트한다 했으니, 맨 앞에 짠 코드면 그만큼 여러 번 테스팅이 이루어져서 신뢰도가 높아진다. 

  - Simplified Debugging : 성공 중간에 Fail이 나면, 어쨋든 직전에 개발한 코드가 문제가 되었다는 뜻이므로, 그 부분을 바로 고쳐주면 편하다. 
    - 물론 그전에 개발했던 것이 연관이 되었을 수 있음. 하지만, 직접적인 연관은 일단 내가 지금 잡고 있는 것으로 인해 에러가 난 것일 것이다. 
    - 직전에 작성했던 코드를 중심으로 디버깅하게 되면, 조금 더 빨리 원인을 찾아서 Debugging할 수 있게 된다.

  - System Documentation : TDD를 하게 되면, Test 할 항목이 정해지게 된다. 어떤 것을 수행하는지 정하고, 그것대로 테스팅하는 것 만으로도 Documentation 이 된다.

### Regression Testing 

+ 자꾸 개발을 하고 작업을 하다 보면, 결국에는 그 코드에 Change가 발생하게 되는 것이고, 그때까지 했던 Test들을 믿을 수 없어 버리기 때문에, 새로 Testing 하는 것이다!
+ 실제로 하라고 하면 대단히 힘들다. 수동적으로 테스팅하는 경우, 힘이 많이 들 테지만, Regression Testing을 자동으로 하게 된다면, 그렇게 힘든 작업이 아니게 될 수 있다. 
  - 그냥 완성을 해서 자동으로 돌리면, 그 전에 했던 애들까지 자동으로 돌리게 되는 것이다. 
  - Change가 반영되기 전에는 계속 성공했을 테니, 개발한 것이 Success 된다면 잘 되어 있다고 믿고 다음 단계로 넘어갈 수 있다. 

## Release Testing
+ 출시하는 Software를 Testing하는 것을 보고 Release Testing이라고 한다. 
+ 개발팀이 아닌 다른 팀이 맡에서 테스팅해본다! 
+ Release Testing 예시 : Beta Testing 
  - Beta Testing도 일종의 Release Testing이라고 볼 수 있다. 

+ 이전 단계의 Testing은 다 개발하기 전에 일어난 Testing 이라서, Testing 하는 환경 자체가 개발 환경이다. 
+ 안드로이드 개발의 경우, 에뮬레이터에서 돌리는 것이 아닌, 실제 환경에서 테스팅하는 것이 Release Testing이다. 

+ Release Testing의 주된 목적은, "사용하기에 충분히 좋은 System인가?" 를 보는 것이다. 
  - 이때까지는 개발 환경에서 Testing을 했기 때문에, 거기에서 테스팅하는 것이 주된 목적이 아닌 것이다,. 
  - 실제로 해당 시스템에 우리가 사용하고자 하는 시스템을 녹였을 때를 기준으로 잘 만들어졌는가? 가 중요하다. 
  - "실제로 내가 사용하고자 하는 환경에서, 그 환경에 의존해서 잘 동작하는가?"
  - "실제 환경에서 동작하는데 있어서 적합한가?" (System 상에서 Failure 이 나면 안된다는 이야기)
    - 정상적인 상황에서 정상적으로 사용할 때, 우리가 원하는 대로 사용하려고 했던 것에 대해서는 반드시 시스템이 죽어서는 안된다!!

+ 그래서 Release Testing의 경우, Black-Box Testing을 많이 하게 된다. 
  - 내부적으로 어떻게 만들어졌는지에 상관없이 그냥 인풋 아웃풋 원하는대로 넣어보면서 테스트 하는 것임. 

### Release Testing and System Testing

+ Release Testing 은 System Testing의 한 종류라고 볼 수 있을 것이다. 
+ Release Testing 과 System Testing의 중요한 차이점 
  - Release Testing은, 개발팀과 완전히 다른 사람들이 진행함. 
  - 아예 개발자가 진행하지 않을 수도 있다. 비개발자가 진행할 수도 있다. (이미 내부를 대충 알고 있으니 그에 맞춰서 테스팅하려고 함)
  - 개발을, 내부를 모르는 상태라면, 모르기 때문에 여러 가지 생각할 수 있는 것들이 있다. 
  - 개발자들이 주로 하는 테스팅은, Defect Testing을 주 목적으로 테스팅을 진행함.
  - Release Testing은, 그런 결함 찾는 테스팅을 하는 것이 아니다. 그냥 쓰는대로 쓰는데, 아무런 문제없이 동작하는지, 그 사이에 성능적으로도 괜찮은지를 체크하며 테스팅하게 된다. 
  - 개발자들이 테스트 할 때는, 에러가 있는지 없는지가 중요하고, Release Testing에서는(개발자가 아닌 사람들 입장에서 보았을 때는) "쓰기 좋은가?" 에 초점이 맞춰져 있는 것이다.
    - 똑같은 프로그램 두개 있음녀, 이 중에 사용자는 더 사용하기 좋은 프로그램을 사용할 것이다. 
   
### Requirements Based Testing 

+ Requirement를 보고 Testing하는 것이다. (Requirement에 맞게끔 시스템이 동작하느냐를 보는 것이 Requirement Testing)
+ Requirement 하나하나 보고 Testing 한다.

### Features Tested by Senario

+ Feature를 Testing 하는데, 시나리오에 의해 테스트하는 것이다. 
+ Feature 예시 : Downloading, Uploading / Authentication / Encryption, Decryption  요런 것들.
+ 요런 기능들을 보면 Feature라고 할 수 있음. Feature 단위로 Test 해야 한다!

### Performance Testing

+ Performance(성능)를 확인한다. 이것도 Release Testing에서 많이 확인하게 된다. 
+ Release Testing의 경우, 정상적인 상황에 대해서 잘 동작하는지 확인하는 만큼, 성능을 테스트하는 것이 의미가 있다. 
+ Performance Testing은 정상적인 상황에 대해서 확인하는 작업을 거치다 보니, Release Testing, 혹은 System Testing 이라고 볼 수 있다.
+ 시스템이 어떤 곳에 사용된다고 나와 있는것이 있다면, 당연히 그 부분에 대해서는 모두 테스팅해 줘야 한다. 
+ 테스트할 때는 점점 시스템 부하가 버거워지는 상황으로 보통 테스트가 진행된다. (여기서 시스템이 Failure날때까지 가면 Stress Testing이다)
  - 반대로는 진행하지 않는다. 
    - 불을 하나도 안 켜본 상태에서 10개 키면, 시스템이 죽을 수도 있지만, 하나하나 키게 되면 그게 다 테스트 결과자료로 남을 것이다.
    - 작은 것부터 하나하나 올려다가 보면, 시스템이 죽을 때까지 올려다가 보면 그 시스템이 얼마나 믿을 수 있는지 최종적으로 알게 될 것이다. 

## User Testing

+ User Testing은 Customer Testing이라고도 많이 이야기한다. 
+ General System 같은 경우, 고객이, 사용자가 누군지 모르므로, 불특정 다수를 위해 만든 시스템이지만, Customized System의 경우, 누가 User(Customer)인지 아는 상황이다. 
  - 사용할 사람이 존재하니, 그 사람들을 기준으로 Testing을 수행하는 것이다. User들이 Input을 제공함. 혹은 User가 직접 테스팅을 수행함.
  - 아무리 잘 만들어놔도 결국에는 User가 만족해야 한다! 
+ 어쨋든 만들어져야 할 수 있기 때문에, System Testing 단계에서 많이 수행된다.
+ 건너뛰고 Acceptance Testing으로 가도 되지만, System Testing 단계에서 안하고 현장에 갔다가 안된다고 빠꾸먹는것보다는 훨씬 낫다. 
