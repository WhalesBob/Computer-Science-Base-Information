< 3장 : Agile Software Development >

목차 : 
    - Agile Method란?
    - Agile Development Techniques
    - Agile Project Management
    - Scailing Agile Methods
    
 
 ** Agile Method 
    
    *** Rapid Software Development
        >> 요즘은, 빨리 개발하는 것이 제일 중요하다!(Time-to-Market) 
          ex)코로나19 터졌을 때, 관련된 서비스를 만들면 처음이라 사람들이 많이 쓰겠지만, 지금 완성해서 내면 이미 관련된 앱들이 많을 것이다!
            -> 그만큼 빨리 만들어야 한다는 것! 제때, 빨리 만드는것보다 중요한것은 없다!
            -> 공공,복지 부분에 있어서는 안그렇겠지만, 판매, 비즈니스를 위해서는 누구보다 빨리 만들어야 사람들이 쓴다. 
        >> 실질적으로 안정적인 Requirement를 가지고 개발하는 것은 거의 불가능하다. 나중에 Change를 잡아넣고 개선하면 된다.
        >> 고객 입장에서는 좋은 방법은 아니다. EarlyAdopter들은, 빠르게 쓰니까 이것저것 문제 생기는데, 나중에 패치해서 나오게 되는 것임. 
        >> Plan-Driven의 경우, Time-to-Market에는 적합하지 못하다. 큰 시스템에, 긴 시스템을 가지고 검증해나가는 방법이기 때문
        >> Agile 개발 방법이 그래서 아직도 많은 사랑을 받게 된다. Delivery 시간을 엄청 줄이고, 빨리 개발할 수 있기 때문
        >> 어떤 앱들은 Update를 굉장히 자주 하는데, 이런 것들이 Agile 방법론으로 만든 것임.
        
    ***  Agile Development
        >> Program Specification / Design / Implementation  3개를 같이 한다
        >> 굉장히 다양한 버전이 나오게 됨.
        >> 버전이 안되면, Incremental 이라도 나온다. 
        >> 이해당사자의 경우, User, 개발자 등등이 다 포함된 것임. 다같이 참여해서 Spec과 Evaluation이 계속 일어남
        >> 잦은 Delivery, 빨리빨리 배포판이 나온다.
        >> 매일마다 하면 관리하기 힘드니, Tool(자동화 테스팅 같은) 것들을 사용한다. 그렇지 않다면, 테스트할때마다 시간 먹을 것임. 
          (Tool들의 도움을 많이 받아야)
        >> Documentation도 적게 해야 함. 대부분 코드를 짜는데 시간을 들이고 문서화는 최대한 적게 만들어야 함! (코드짜는데도 바쁘다)
        
    *** Agile Methods : 
        >> 1980년~1990년대쯤 만들어졌다.
        >> "코드에 집중". 설계보다는 코드에 집중해라! 만들면 장땡이라는 마인드.
        >> 그다음 다시 설계를 하자. 흔히 잘 짜여진 설계를 가지고 만드는것보다는 거리가 멀다. 
        >> 만약 건축물을 이렇게 하면, 망할것임. 실제로 지반공사 하는게 더 중요함!(뼈대잡는게)
        >> 하지만, 이런 프로그램들은 아무리 망해도 생명에 지장이 있는 것은 아님! 치명적인 피해가 일어나지 않는다. 
        >> 의료, 군사용, 교통(자율주행) 프로그램들이 이렇게 개발되면 망한다! Safe Critical System의 경우 Waterfall로 많이 한다
        >> Agile은, 그렇게 해도 되는 애들만 보통 이렇게 Time-To-Market함. Iterative-Approach/빨리 Delivery / Change에 대한 것도 빨리
           해결해 줘야 함!  -> 이렇게 되면 Agile이 되게 좋다. (그래도 되는 애들만 한다~)
           
        >> 목표 : Reduce Overhead ( Document 만드는데 시간을 너무 많이 쓰지 마라~). 문서화를 최소화시키는 것. 그 시간에 개발해라!
        (Plan-Driven이랑은 다르다. 긴 시간동안 큰 프로젝트를 하고, 여러명이 붙어 하고, 문서를 계속 확인하는데 Agile은 일단 짜라는 식! 
        나중에 바꾸면 된다는 마인드)
        
   *** The principles of Agile Methods
   
    >> Customer Involvement(팀에 Customer를 붙여서 하자)
    >> Incremental Delivery(자주, 하나하나 내자.)
    >> People not process (절차보다는 같이 일하는 팀원들이 더 중요하다!)
    >> Embrace Change(Change를 우선적으로 반영해라!)
    >> Maintain Simplicity(단순함을 유지하자. Simple하게 일단 구현하자! 구현하고 확인하자) 
    
    >> 개발을 간결하게 하자~
    
   *** Agile Method Applicability
    >> Agile 방법론을 사용할 만한 곳은, 작거나 중간정도 급 되는 프로젝트에 쓴다
    >> Safety-Critical한 곳에는 쓰면 안됨. 에러가 지장을 안 주는 선의 프로젝트에서만 사용가능함. 
    >> Custom-System(이미 어떤 조직에 맞게끔 커스텀하는! Customer가 직접 참여할 수 있는 형태의 개발)
        -> 아무리 중간, medium급이라도, Customer가 없으면 바로 수정받고, 새로 Deliver할 수 없다!
        
 
 
 ** Agile Development Technique
 
    *** Extreme Programming
        >> 프로그래밍 자체에 굉장히 많은 시간을 소요한다!
        >> 매일마다 새로운 버전이 몇번씩 나오는 방법(정말 극단적인 방법. 최소한 하루에 하나는 나오고, Customer가 직접 참여해 Feedback함.)
        >> 최소한 2주에 한번은 Delivery해야 한다. (Version이 꼭 나와야 한다)(주기가 엄청나게 빠름)
        >> 하지만 이렇게까지 하려고 무리해서 하는 것은 올바른 방법이 아니다. 
        >> 새로운 버전 나올때마다 테스트를 반드시 진행해야 함. 
        
    *** The Extreme Programming Release Cycle (그림 3.1)
        
        Select User Stories   --------> Break down  ----------------> Plan Release 
         for this release             Stories to tasks                     |
               ^                                                           |
               |                                                           |
          Evaluate       <--------------     Release     <-----------   Develop/Integrate/
           System                           Software                     test Software
           
           
           >> Select User Stories for this release : "유저 스토리" -> 일종의 스토리 or 시나리오이다.  
                                                     사용자가 어떠한 컨셉을 가지고 어떤 소프트웨어를 만들어 달라고 하는 것. 
              -> 이거 듣고 전체 한 사이클 돌면 Running Version 한개 나온다. 
              
              -> 첫 버전을 가지고, 이 부분은 고객의 원했던 부분이 아닌 것. 어떤 부분이 누락되었는지, 등등을 받으면 
                 새로운 스토리를 받았다고 할 수 있다. 그럼 다시 이 Story를 Task로 쪼개 나가면서 하면 됨.
                 
              -> Top-Down 방식! 어떤 스토리가 있으면 이 스토리에서 개발해야 할 부분들을 쭉 뽑아내는 것.
              
           >> Break down stories to tasks : 
              -> 앞서 할 때는 스펙보고, 스펙에 해당하는 것만 만드는데, 이겨서는 스토리를 가지고 직접 그 Task를 만들어야 되는 것이다
                  
              ->앞 단에서는 Requirement 단위로 진행이 되었다면, Task 단위에서는 Requirement 한개, 혹은 여러 개를 하나의 Task로 만들어서 진행함
                (Task 단위로 일이 진행된다)하나의 Requirement가 하나의 Task일수 있고, 여러 Requirement를 묶어 하나의 Task로 할 수도 있다.
         
                ex) Task : 로그인 구현 -> 로그인 기능 안에는 어떤 것을 만족해야 하는지, 아이디는 무엇을 만족해야 하는지, 등의 요구사항이
                                          생길 수 있다. 이 전체를 뭉떵그려서 하나의 Task로 갈 수도 있다는 뜻.
                                          
           >> Plan Release : 계획을 늘린다. 
           >> Development / Integrate/ Test software : 그냥 개발/통합/소프트웨어 테스트
           >> Release Software : 소프트웨어 배포. 꼭 최종 사용자까지 배포가 아닌, 팀 내의 Customer에게 보여주는 것.
           >> Evaluate System : System 평가 
           
      *** Extreme Programming Practices(원칙)
          >> Incremental Planning : 그냥 단계적으로 해라! 쪼개서 해라! 쪼개서 조금씩 조금씩 개발하면서 계속해서 Version Update!
          >> Small Release : 작은 것부터 계속 Release 하는 것
                    ex) 카카오톡 1.0.1 / 1.1.1 이런 Version들
                            -> 제일 앞이 Major버전, 중간은 Minor 버전 숫자. 마지막은 디버깅 에러 fix할때 붙는 버전
                            -> 이렇게 3개 자리 쓰는 것이 일반적임. 
                            -> Release 할때마다 제일 끝부터 계속 숫자가 바뀔 것이다. 
                            -> 바뀌다가 다 Fix하게 되면 작은 기능 완성되고, 중간 숫자가 바뀌는 식. 이런 식으로 Release 계속한다. 
           
          >> Simple Design : 최대한 디자인을 심플하게! 가져가라는 것. 복잡하게 디자인을 구조적으로 하는 것이 아니라, 우선
                              기능적으로 만드는 것에 집중해서, 돌아가게끔 하는 것. 그러다 보니 단순하게 할 수 밖에 없다. 
                              
          >> Test-First Development : Running Version 나올 때마다 테스트를 모두 수행한다! 앞단에서의 Unit Test ~ Integration Test
                                       까지 다 하면 좋겠지만, 할 때마다 계속 바뀌기 때문에 자동화 테스트라도 해야 함.
                             
                             (Test-Driven-Development : 개발하기 전부터, 이 기능을 만족하려면 이 테스트를 했을 때 만족해야 해!
                             하고 테스트 케이스를 먼저 만드는 것임. 그리고 그렇게 동작하게끔만 먼저 만드는 것이다. ) 
            
          >>  Refactoring : Software를 말 그대로 "Refactor", 새롭게 만드는 것이다. 
                        -> 디자인도 심플하게 하면서, 단순한 구조로 만들다 보면 코드 양도 엄청 늘어나도, 이상하게 덩치가 커지기
                           시작한다. 이제 그때가면 새로 구조를 잡는 것이다. 처음부터 구조를 잡고 가는 것이 아니라 만들어 놓고 
                           구조를 새로 잠는 것임.  (ex:과제할 때도, 이거 필요없네! 이 함수는 빼자! 하는 경우가 Refactoring)
                           
                        -> Waterfall 모델 같은 경우에는 Refactor를 할 필요가 없다! 그냥 설계대로 짜면 되는 거라서
                        -> Agile의 경우에는 계속해서 바뀌기 때문에 구조를 그때 그때 맞춰서 조금씩 바꿔야 할 필요가 생긴 것들이라
                           바꾸는 것이다. 
                           
          >> Pair Programming : 반드시 짝을 이뤄서 프로그래밍하라! 이렇게 되면 무조건 두명이서 코드를 짜기 시작하는데, 한명은 
                                열심히  짜고 있고, 다른 한명은 뒤에서 보는 것이다. 마치 한명은 게임하는데 다른 한명은 뒤에서 
                                "훈수"두는 것처럼! (제 3자 입장에서 보면 직접 1인칭으로 하고 있는 사람들이 발견하지 못하는 것들을
                                3자 입장에서 보았을 때 발견할 수 있다. 그래서 잘못된 것이 있으면 뒤에서 잘못되었다고 "훈수" 두는
                                것이다!)(짜는 사람이 힘들어지면, 이제 역할을 교체해서 훈수 두던 사람이 훈수 당하는 사람으로 
                                프로그래밍 하는 것이다)
                                
          >> Colloective Ownership : Pair Programming할때, Agile Method가 워낙 Cycle이 빠르게 돌기 때문에, 어떤 개발자가 중간에 
                                     투입된다 하더라돋 개발을 할 수 있어야 함. 그래서 개발자는 코드의 일부만 자기 것이라고 생각하
                                     는게 아닌, 해당 프로젝트의 모든 코드가 "자신의 코드다"라는 의식을 가지고 개발해야 한다는 것임. 
                                     (언제 누가 대체될지 알 수 없기 때문)
         
          >> Continuous Integration : 요즘 대두되고 있는 <CI/CD>(Continuous Integration/Continuous Development). 지속적인 통합을
                                     이야기한다.  매일마다 만들면 새로운 Running Model 이 계속 나오니, 만들면 통합하고 만들면 통합하는
                                     개발을 반복한다는 이야기이다. 나중에 한방에 통합하는 것이 아님! 만들면 그때그때 바로 통합해서 
                                     버전 관리가 되고, 또 다른게 만들어지면 하나의 Release Version이 나오는 식.
                                     
          >> Sustainable Pace : 무리해서 하지 말자! 페이스를 안정적으로 유지하자! 무리해서 해봐야 밤샘 하루이틀은 할 수 있지만, 
                                3,4일 지나면 그때부터는 Code Quality가 떨어질 것임. (하루에 8시간 이상 넘겨서는 코드 짜지 말자)
                                (너무 빡세게 하면 번아웃이 올 수 있으니 쉬었다가 다시 하자는 마인드)
                                (2주에 한번씩은 최소한 Incremental Development를 해야 하기 때문. 항상 페이스를 유지하면서 일하자.) 
          
          >> On-Site Customer : "현장에 고객이 있어야 한다." 팀 안에 고객이 잠깐씩만 있는 게 아니라 아예 상주하는 것으로 가야 함. 
                                말 그대로 상주하며 팀 전체를 돌아다니면서, 이상한 것이 나오면 "어떤게 잘못되었으니 고쳐달라!" 하며
                                잔소리하면서 요구하는 것임. 그래야 원하는 대로 빨리 만들어질 것이다.
              
              
      *** XP(eXtreme Programming) & Agile 개발의 규칙
      
          >>  Incremental Development 를 해야 한다. / 빠르게 시스템을 Release 해야 한다. / Customer는 풀타임 상주 /
              Pair Programming... (앞에서 나왔던 이야기 바로 다시 하는 느낌)
              
   
      *** Influential XP Practice 
      
          >> User Story가 결국 Spec이다!    
               -> User Story가 Spec보다 더 중요하고, 결국 그것이 Spec과 직결된다.
          >> 중간중간에 Refactoring하자!
          >> TDD/TFD 하자. 
          >> Pair Programming
          
      
      *** User Stories for Requirements
      
          >> User Requirement가 User Story 또는 Senario로 표현된다는 이야기이다. 
          >> 물론 스토리와 시나리오 안에 없는 것들도 들어가겠지만, 일단 이 두개가 먼저 만족이 되어야 한다는 이야기. 
          >> Customer 가 Story를 선택할 때, 다음 Release Version에 어떤 것이 들어가야 할지를 직접 선택한다. 
                (어떤것을 먼저 개발할지 정하는것)
          >> ex : "Prescribing medication" story  -> 스토리를 들어보고 Task를 짜서 상세히 구체화하기.
          
      *** Refactoring 
       
          >> 왜 Refactoring을 해야 하는가?
            -> Changing은 결국 발생할 것이기 때문에, 반드시 계속 Change를 고려를 하면서 프로그램을 짜는 것이 현명하다!
            -> 개발 주기가 짧아져서 더더욱 필요함. Refactoring!
                (어차피 다른 방법론으로 할 때도 Change관리를 하는것이 계속 필요함. 어차피 다른 방법으로 한다 하더라도, Design하는 
                 단계가 있기 때문에, 코드를 짜면서도 개발자가 놓치는 부분들이 항상 생긴다. 그럼 그게 다 Change로 돌아온다!)
        
            -> Refactoring하는 것이 나중에 Change를 반영하는데 있어 더 쉽다. 
          
          >> Change가 발생할 때, 당장 어떤 구조를 바꾸지는 않더라도, 미리미리 Change에 대한 부분을 바꿔놓는게 나중을 위해서 훨씬
             더 좋다. (하지만, 대부분의 개발자들이 당장 할 것이 많아서 안한다.)
             
            -> 프로젝트 초반에는 괜찮지만, 나중에는 이 Change를 고려안하고 한 것 때문에 고통받는다!
            -> Refactoring을 습관적으로 하자!!! ★
            -> 프로젝트 짜다가도 좋은 아이디어가 생각났으면, 그때 고쳐야 한다. 나중에 해야지 라는 마인드로 하면 그때는 머릿속에서
               없어져 있을 것이다. (순간적으로 지나가는 아이디어라 그렇다)
          
          >> Software Improvement Care를 해야 한다! 즉시 안 필요해도 Refactor 하자!
            -> Refactoring 하는 것 자체가 해당 소프트웨어에 대한 이해도를 올리는 작업이다. 그렇기 때문에 문서화를 할 필요도 없어짐. 
            -> Software를 구조적으로 계속 바꿔나가는데 굳이 문서화를 해야 할 필요가 없음
            -> 어떤 변화가 일어나도, 코드가 잘 구조적으로 되어 있고 정리가 잘 되어 있을 것이다!(Refactoring을 자주하면)
            -> 물론, 어떤 Change는, 전체 구조를 다 바꿔야 하는 상황을 만들 수도 있지만, 그래도 미리미리 조금씩 바꿔 놓으면, 전체
                구조를 다 바꿀때도 드는 비용이 훨씬 더 적다! 
            
          >> Refactoring 예시 :
            -> 중복적인 코드 제거. ( 함수, 클래스를 빼고 넣고 해서)(상속하면 또 중복적인 코드 없앨 수 있다)
            -> 용어, 메소드, 클래스에 대한 네이밍을 정확히 하면 혼동없이 이해가 가능하다
            -> 코드를 숨기거나 밖으로 빼는 등의 위치이동을 해서 조금 더 가독성 있게 만들자!
      
      
      *** Test-First Development           

          >> 테스트를 먼저 하는 개발 방법론. 테스트가 우선이다! 테스트할 것(Test-Case)를 먼저 List-up 해놓고 그다음 각각의 
             테스트 케이스에 부합하는 대로 개발한다! 
              
             -> 그냥 요구사항대로만 짜다가 테스트 보면은, 어떤 것을 깜빡했을 수도 있다. 혹은 어떤 부분에 있어서 오류검증이 안된
                부분이 있을 수 있다. 그럼 그부분에 있어서 나오는대로 계속 추가해야만 할 것이다. 
         
          >> 왜 이게 좋은 방법인가?
             -> 보통 개발자는 테스터랑은 별개로 있는데, 본인이 입력값 넣고 본인이 테스트해서, 안되는 부분이 많다.(막상 PS해도 그렇잖아)
             -> 그렇게 실제로 돌려보면, 안되는 것이 더 많다. 개발하는 입장에서는 앞서 유저 시나리오대로만 짜기 때문에, 그에 해당하지
                않는 것들은 고려하지 않는 경우가 많다.(무의식적으로도 그렇다)
             -> 차라리 테스터 입장에서도, "이런 테스트 케이스는 통과하게 만들어 주세요!" 하고 던져주는 것이 더 낫다.
             
             -> 자동화할 수 있는 Test 환경.(AUtomated Test Harnesses) Test할 목록들이 전부 다 정해져 있다!
                (걔들만 다 통과하면 최소한 개발자가 욕먹을 일은 없다~)
                
                
      *** Test-Driven Development     

          >> Test-First Development와 맥락을 같이 한다.
          >> 자동화 테스트 툴 같은 것들을 잘 사용해서, 테스트 중심의 개발을 하자!
            (테스트하는 사람에 따라 테스트 에 넣는 값이 달라질 테니, 차라리 자동화 테스팅 툴을 사용해서 개발을 하자~. 
             그렇다면, 테스트 결과도 일괄적으로 나올 것이다! 그래야 테스트 결과도 신뢰성이 높아진다.)
             
      *** Customer Involvement 
          
          >> 중요한 것은, Customer가 계속 Full-Time으로 있어야 하고, 그래서 모든 새로운 Code는 Customer에 의해 Validate 되는 것.
          >> Customer의 Need에 맞게끔 다 Validate되는 것이다. 
          >> 단순 Verification이 아니라, "Validation" 되어야 하는 것임! (+ Customer가 Accptance Test까지!)
      
      **** Test Case Description 
           -> Test 에 해당하는 Test description 을 보고 보통 Test Case라고 이야기한다 
           -> 하나의 Test Case는, 각 한 가지에 대해서 검사하는 것임. 
           -> 하나의 Task(Task일수도 있고, Function일수도 있음) 에 대해서 간이 시험하는 것이다.
           -> Test Input/Output을 가지고, Input/Output가지고 비교하면 되겠다. 당연히 Test Case도 <Input,Output> Pair로 나옴.
           -> 이러한 Test Case들이 여러개 모이면 Test Sweep. Test Case를 일렬로 쭉 나타낸 것이 Test Senario가 된다. 
           
           
      *** Test Automation 
          
          >> 별거없다. 그냥 "자동화하자". 자동화 툴로도 "혼자서도" 동작해야 하는 것임.(Stand-Alone)           
          >> 테스트 자동화는, 테스트와 개발을 빨리 하고 쉽게 하게 해준다. 
          >> 사람이 하는 것보다 정확하다. (그때그때 안 다름)
          >> 몰론, 테스트 케이스 시나리오가 다 나와 있는 상태에서 똑같이 하면, 사람이 해도 잘 될수 있다. 하지만, 그걸 자동으로
             실행하는 것과 사람이 하나하나 입력하는 것도 시간적 차이가 있음. 결과 나오면 결과 기록해야 되니 시간을 더 먹는다.
             ->테스트 자동화가 꼭 필요하다!
             
             
      *** Problem with Test-First Development(문제점!)
          
          >> TFD, TDD를 하면 개발자가 개발하는 것이 더 쉬워지고 잘해질 수는 있다. 정해진 것 내에서는! 있는 항목에 있어서는 잘한다.
          >> 테스트에 없는 것은 고려하지 않겠다는 의미이기도 하니, 테스트 항목에서 빠져버리게 되면, 그 부분은 전혀 고려하지 않을 것이다.
          >> 특정 부분 테스트 한다니까 그것만 되면 된다는 의미?! 아이러니한 상황이 벌어지는 것이다. 모든 가능한 상황을 다 고려해야 하는데 
             고려하지 않게 됨. 개발을 하는 것이, 결국 "마주한 문제점을 해결하기 위해" 만드는 것이 프로그램인데, 그런 "문제"가 생길 수 
             있는 모든 경우에 대해 다 알고 있다면 더이상 문제가 아니게 된다! 미리 다 감지해 내면 되는 것이기 때문. 
          
          >> +) 테스팅 자체에도 이런 문제는 있다. 특정 시스템을 테스팅했다고 해서 "이 시스템이 안정적이다. 완벽하다!" 라고 이야기할 
                수는 없다. 모든 경우에 대해서 다 테스팅할 수는 없기 때문이다. 최소한, 개발팀이 테스팅 한 부분에 대해서는 보증할 수 
                있다는 이야기가 그래서 나오는 것이다. 
             +) 가능한 경우의 수가 100개 있다 치면, 100개 다 테스팅 안한다. 이것이 Test-First Development의 가장 큰 맹점이다.     
          
          >> Incremental 하게 개발할 때는 또 이것이 조금 어려울 수도 있다. 아직 해당 기능을 출시하지 않았는데, 테스트 케이스에서는
             아직 출시하지 않은 기능까지 통합해서 테스팅하라고 할 수도 있기 때문이다. 당연히 안되는 것임. 
          
      *** Pair Programming
          
          >> 앞에서 한명하고, 뒤에서는 훈수두고
          >> 서로서로 짜는 스타일이 조금씩 다르기 때문에, 다른 사람이 짜는 것을 보고 본인 스스로도 조금씩 배울 수 있다. 
          >> 생각보다, 따로따로 하는것보다 둘이서 같이 하는것이 하는 것이 효율이 더 좋기도함.



 ** Agile Project Management
 
          >> 가장 중요한것 : 
                -> (제시간에 출시하는 것! + Budget(예산)). Agile에서는 이거 하나를 위해 앞뒤 다 무시하고 개발에만 집중하는 것이므로 
                   당연히 제시간에 출시하는 것이 제일 중요하다! "다른거 다 필요없다! 무조건 개발이 제일 중요하다!"는 마인드. 
                   그리고, 예산이 주어져 있는 것에서 그 기간안에 완수를 해야 딱 예산안에 끝낼 수 있다. (월급주는거)
                
                -> 프로젝트 매니저의 경우 이런 것들을 항상 고민해야 한다.
                
          >> 대부분의 프로젝트는 Plan-Driven(어떠한 계획에 따라서 하는) 으로 가는 것이 일반적임(정해진 대로 가니까 실패확률 low)
          >> 이상적으로는, 안되는 부분이 있으면 다음 프로젝트에서 해결하면 될 것 같지만, 막상 현실에서는 그렇게는 안된다. 
          >> Incremental Development를 가지고, 실제 현실에 맞게끔 조금씩 다르게 적용할 수 있다! Agile의 경우 뭔가 딱 정해져 있는 것은
             아니라는 것임. 
      
      *** Scrum
          
          >> Agile Method를 Management하는데 있어서 필요한 것이 Scrum이다!
          >> Incremental vs Iterative
                
                -> Incremental 같은 경우에는, 단계적으로 개발하는 것을 말함.
                -> Iterative 같은 경우, 같은 것을 똑같이 반복하는 것이다.
             
         >> 진행방식 : 
                -> back-log (기록)들을 가지고, 기록하며 진행을 함. 
                -> Customer가 back-log를 보고, 고치고 싶은 부분(기존의 시스템 업데이트, 기존 시스템을 새로운 시스템으로 변환 등)
                   을 미팅을 하자고 하여 이야기함. 
                   
                -> Sprint Back-Log : 미팅을 해서 나온, 새로 해야 될 부분에 대한 back-log를 만듬
                -> 이러한 Back-Log가 모여서 Task가 된다. 
                -> 새로 할 것들이 있으면, 진행하고(Sprint), 그것들에 대한 리뷰도 다시 진행함. 
                    (리뷰 : 내가 짠 코드나 문서를 다른 사람과 함께 보고, 고쳐나가는 것)
                -> 이후 Daily Scrum Meeting 해서 만들어진 것 도 업데이트하고, 스크럼 마스터가 확인하고 Product Back-Log를 다시
                   보내주게 됨. 
                   
          >> 바로 위의 내용은 개발이 아니라 프로젝트 관리이다! 
                -> 무엇을 해야 하고, 해야 하는 것들을 어떻게 해결하며, 해결안된 것이나 추가적으로 해결해야 될 부분들은 다시 기록한다. 
                
      *** Scrum Sprint Cycle (그림 3.2)  
      
      
      
