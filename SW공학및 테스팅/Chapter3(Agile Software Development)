< 3장 : Agile Software Development >

목차 : 
    - Agile Method란?
    - Agile Development Techniques
    - Agile Project Management
    - Scailing Agile Methods
    
 
 ** Agile Method 
    
    *** Rapid Software Development
        >> 요즘은, 빨리 개발하는 것이 제일 중요하다!(Time-to-Market) 
          ex)코로나19 터졌을 때, 관련된 서비스를 만들면 처음이라 사람들이 많이 쓰겠지만, 지금 완성해서 내면 이미 관련된 앱들이 많을 것이다!
            -> 그만큼 빨리 만들어야 한다는 것! 제때, 빨리 만드는것보다 중요한것은 없다!
            -> 공공,복지 부분에 있어서는 안그렇겠지만, 판매, 비즈니스를 위해서는 누구보다 빨리 만들어야 사람들이 쓴다. 
        >> 실질적으로 안정적인 Requirement를 가지고 개발하는 것은 거의 불가능하다. 나중에 Change를 잡아넣고 개선하면 된다.
        >> 고객 입장에서는 좋은 방법은 아니다. EarlyAdopter들은, 빠르게 쓰니까 이것저것 문제 생기는데, 나중에 패치해서 나오게 되는 것임. 
        >> Plan-Driven의 경우, Time-to-Market에는 적합하지 못하다. 큰 시스템에, 긴 시스템을 가지고 검증해나가는 방법이기 때문
        >> Agile 개발 방법이 그래서 아직도 많은 사랑을 받게 된다. Delivery 시간을 엄청 줄이고, 빨리 개발할 수 있기 때문
        >> 어떤 앱들은 Update를 굉장히 자주 하는데, 이런 것들이 Agile 방법론으로 만든 것임.
        
    ***  Agile Development
        >> Program Specification / Design / Implementation  3개를 같이 한다
        >> 굉장히 다양한 버전이 나오게 됨.
        >> 버전이 안되면, Incremental 이라도 나온다. 
        >> 이해당사자의 경우, User, 개발자 등등이 다 포함된 것임. 다같이 참여해서 Spec과 Evaluation이 계속 일어남
        >> 잦은 Delivery, 빨리빨리 배포판이 나온다.
        >> 매일마다 하면 관리하기 힘드니, Tool(자동화 테스팅 같은) 것들을 사용한다. 그렇지 않다면, 테스트할때마다 시간 먹을 것임. 
          (Tool들의 도움을 많이 받아야)
        >> Documentation도 적게 해야 함. 대부분 코드를 짜는데 시간을 들이고 문서화는 최대한 적게 만들어야 함! (코드짜는데도 바쁘다)
        
    *** Agile Methods : 
        >> 1980년~1990년대쯤 만들어졌다.
        >> "코드에 집중". 설계보다는 코드에 집중해라! 만들면 장땡이라는 마인드.
        >> 그다음 다시 설계를 하자. 흔히 잘 짜여진 설계를 가지고 만드는것보다는 거리가 멀다. 
        >> 만약 건축물을 이렇게 하면, 망할것임. 실제로 지반공사 하는게 더 중요함!(뼈대잡는게)
        >> 하지만, 이런 프로그램들은 아무리 망해도 생명에 지장이 있는 것은 아님! 치명적인 피해가 일어나지 않는다. 
        >> 의료, 군사용, 교통(자율주행) 프로그램들이 이렇게 개발되면 망한다! Safe Critical System의 경우 Waterfall로 많이 한다
        >> Agile은, 그렇게 해도 되는 애들만 보통 이렇게 Time-To-Market함. Iterative-Approach/빨리 Delivery / Change에 대한 것도 빨리
           해결해 줘야 함!  -> 이렇게 되면 Agile이 되게 좋다. (그래도 되는 애들만 한다~)
           
        >> 목표 : Reduce Overhead ( Document 만드는데 시간을 너무 많이 쓰지 마라~). 문서화를 최소화시키는 것. 그 시간에 개발해라!
        (Plan-Driven이랑은 다르다. 긴 시간동안 큰 프로젝트를 하고, 여러명이 붙어 하고, 문서를 계속 확인하는데 Agile은 일단 짜라는 식! 
        나중에 바꾸면 된다는 마인드)
        
   *** The principles of Agile Methods
   
    >> Customer Involvement(팀에 Customer를 붙여서 하자)
    >> Incremental Delivery(자주, 하나하나 내자.)
    >> People not process (절차보다는 같이 일하는 팀원들이 더 중요하다!)
    >> Embrace Change(Change를 우선적으로 반영해라!)
    >> Maintain Simplicity(단순함을 유지하자. Simple하게 일단 구현하자! 구현하고 확인하자) 
    
    >> 개발을 간결하게 하자~
    
   *** Agile Method Applicability
    >> Agile 방법론을 사용할 만한 곳은, 작거나 중간정도 급 되는 프로젝트에 쓴다
    >> Safety-Critical한 곳에는 쓰면 안됨. 에러가 지장을 안 주는 선의 프로젝트에서만 사용가능함. 
    >> Custom-System(이미 어떤 조직에 맞게끔 커스텀하는! Customer가 직접 참여할 수 있는 형태의 개발)
        -> 아무리 중간, medium급이라도, Customer가 없으면 바로 수정받고, 새로 Deliver할 수 없다!
        
 
 
 ** Agile Development Technique
 
    *** Extreme Programming
        >> 프로그래밍 자체에 굉장히 많은 시간을 소요한다!
        >> 매일마다 새로운 버전이 몇번씩 나오는 방법(정말 극단적인 방법. 최소한 하루에 하나는 나오고, Customer가 직접 참여해 Feedback함.)
        >> 최소한 2주에 한번은 Delivery해야 한다. (Version이 꼭 나와야 한다)(주기가 엄청나게 빠름)
        >> 하지만 이렇게까지 하려고 무리해서 하는 것은 올바른 방법이 아니다. 
        >> 새로운 버전 나올때마다 테스트를 반드시 진행해야 함. 
        
    *** The Extreme Programming Release Cycle (그림 3.1)
        
        Select User Stories   --------> Break down  ----------------> Plan Release 
         for this release             Stories to tasks                     |
               ^                                                           |
               |                                                           |
          Evaluate       <--------------     Release     <-----------   Develop/Integrate/
           System                           Software                     test Software
           
           
           >> Select User Stories for this release : "유저 스토리" -> 일종의 스토리 or 시나리오이다.  
                                                     사용자가 어떠한 컨셉을 가지고 어떤 소프트웨어를 만들어 달라고 하는 것. 
              -> 이거 듣고 전체 한 사이클 돌면 Running Version 한개 나온다. 
              
              -> 첫 버전을 가지고, 이 부분은 고객의 원했던 부분이 아닌 것. 어떤 부분이 누락되었는지, 등등을 받으면 
                 새로운 스토리를 받았다고 할 수 있다. 그럼 다시 이 Story를 Task로 쪼개 나가면서 하면 됨.
                 
              -> Top-Down 방식! 어떤 스토리가 있으면 이 스토리에서 개발해야 할 부분들을 쭉 뽑아내는 것.
              
           >> Break down stories to tasks : 
              -> 앞서 할 때는 스펙보고, 스펙에 해당하는 것만 만드는데, 이겨서는 스토리를 가지고 직접 그 Task를 만들어야 되는 것이다
                  
              ->앞 단에서는 Requirement 단위로 진행이 되었다면, Task 단위에서는 Requirement 한개, 혹은 여러 개를 하나의 Task로 만들어서 진행함
                (Task 단위로 일이 진행된다)하나의 Requirement가 하나의 Task일수 있고, 여러 Requirement를 묶어 하나의 Task로 할 수도 있다.
         
                ex) Task : 로그인 구현 -> 로그인 기능 안에는 어떤 것을 만족해야 하는지, 아이디는 무엇을 만족해야 하는지, 등의 요구사항이
                                          생길 수 있다. 이 전체를 뭉떵그려서 하나의 Task로 갈 수도 있다는 뜻.
                                          
           >> Plan Release : 계획을 늘린다. 
           >> Development / Integrate/ Test software : 그냥 개발/통합/소프트웨어 테스트
           >> Release Software : 소프트웨어 배포. 꼭 최종 사용자까지 배포가 아닌, 팀 내의 Customer에게 보여주는 것.
           >> Evaluate System : System 평가 
           
      *** Extreme Programming Practices(원칙)
           >> Incremental Planning : 그냥 단계적으로 해라! 쪼개서 해라! 쪼개서 조금씩 조금씩 개발하면서 계속해서 Version Update!
           >> Small Release : 작은 것부터 계속 Release 하는 것
                    ex) 카카오톡 1.0.1 / 1.1.1 이런 Version들
                            -> 제일 앞이 Major버전, 중간은 Minor 버전 숫자. 마지막은 디버깅 에러 fix할때 붙는 버전
                            -> 이렇게 3개 자리 쓰는 것이 일반적임. 
                            -> Release 할때마다 제일 끝부터 계속 숫자가 바뀔 것이다. 
                            -> 바뀌다가 다 Fix하게 되면 작은 기능 완성되고, 중간 숫자가 바뀌는 식. 이런 식으로 Release 계속한다. 
           
           >> Simple Design : 최대한 디자인을 심플하게! 가져가라는 것. 복잡하게 디자인을 구조적으로 하는 것이 아니라, 우선
                              기능적으로 만드는 것에 집중해서, 돌아가게끔 하는 것. 그러다 보니 단순하게 할 수 밖에 없다. 
                              
           >> Test-First Development : Running Version 나올 때마다 테스트를 모두 수행한다! 앞단에서의 Unit Test ~ Integration Test
                                       까지 다 하면 좋겠지만, 할 때마다 계속 바뀌기 때문에 자동화 테스트라도 해야 함.
                             
                             (Test-Driven-Development : 개발하기 전부터, 이 기능을 만족하려면 이 테스트를 했을 때 만족해야 해!
                             하고 테스트 케이스를 먼저 만드는 것임. 그리고 그렇게 동작하게끔만 먼저 만드는 것이다. ) 
            
           >>  
                                       
