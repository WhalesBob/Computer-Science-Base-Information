< 2장 : Software Processes >

* Topics Covered
- Software Process Model
- Process 활동(Activities)
- 변화가 생겼을 때 Changing
- Process Improvement


** Software Process(개발 프로세스)
  -> 소프트웨어 개발 시 필요한, 정형화된 활동
    >> 건물 짓는 것에 많이 비유한다. 단순히 "아파트를 짓는다" 는것이 아닌, "방은 몇 개인지 등등"을 정하고 나서 건축을 하는 느낌이다. 
  
  -> Specification : 
    >> 위에서 말한 소프트웨어의 "스펙"을 정하는 것. 가급적 상세하게!
  
  -> Development(Design and Implementation) : 
    >> 위에서 말한 해당 스펙을 가지고, 세세한 "디자인" 을 먼저 진행한다! (디자인 설계 단계)
    >> 위에서 말한 디자인 단계가 전부 이루어지고 나면, 그제서야 Implementation(구현)을 하는 것이다. ( 설계대로! )
     
  -> Validation : (소비자가 원하는 모습과 일치하는지! (1장에서 상세히 정리)(복붙하기))
  
  -> Evolution : (상황, 정보의 변화에 맞게 새로 evolution!  (1장에서 상세히 정리)(복붙하기))
  
   -> 스펙이 상세할수록 디자인하기 쉽고, 디자인이 상세할수록 구현하기는 쉽다. 하지만, 상세하지 않다고 해서 디자인이 안 되거나 
      구현이 안 되는 것은 아니다! 
      
** Plan-driven and Agile Process
  -> 개발을 할 때 크게 두 가지 방법으로 나눌 수 있다! ( Plan-Driven vs Agile )
  -> Plan-Driven : 
    >> 말 그대로 계획이 모두 정해져 있는 것.
    >> 만약 처음에 1년 동안 개발한다고 정해 두었다면, 1년치 계획을 다 짜는 것이다. 그리고 수행하는 것.
    >> 뭔가 다 정해져서, 바뀔 일이 없을 때 해당 방법을 사용하는 것이 유리하다. 
    >> ex) 방산 프로젝트 / 한번 만들어 본 것을 다시 만들 때(이미 어떻게 흘러가는지 계획이 다 있는 경우)
    
  -> Agile : 
    >> 딱히 엄청 커다란 계획같은 것은 없다. 단지 계획은 그냥 Incremental(점진적으로) 하는 것.
    >> 개발하다 보면 뭔가 또 바뀌는 사항 같은 것들이 있을 것이다!
    >> 바뀌면 그에 맞춰서 또다시 계획을 짜고 개발하는 것을 무한 반복하는 것이다.
    >> 이러다가 또 고객의 요구사항에 따라 계속 반복하는 것임.
    >> 요구사항이나, 상황이 분명히 바뀔 것 같을 때 사용하는 것이 유리한 개발 방법이다. (해당 변경건으로 인해 계획 내용이 바뀔 것이기 때문)
    >> 나쁘게 말한다면, 그냥 마구잡이로 개발하는 것. 일단 고객이 있으니, 어떻게든 개발해보고 고객에게 보여주고, 아니라고 하면 그에 맞춰서 
       또 개발하는 것이다. 
    >> ex) Plan-driven 의 사례가 아닌 대부분의 사례
       
  -> (실제로는, 실제적인 개발 프로세스에는 두 가지 개발 방법의 요소가 둘 다 섞여 있는 경우가 많다. 두가지 방법 다 맞는, 혹은 틀린 방법은 
      아니다. 상황에 따라 두가지 방법 중 더 잘 맞는 방법을 선택하는 것이다.)
      
 ** 개발 프로세스 모델
 
  -> Waterfall model : 
    >> Plan-Driven 개발방법의 대표적인 사례. 폭포수가 아래로만 쭉 떨어지듯이, 거꾸로 올라가지 않고 한 방향으로 쭉 진행하는 모델
    >> Specification / Development / Validation 단계별로, 한 단계를 지났으면 그 단계로 다시 올라가지 않는다. 
      (Specifiation이 끝나고 Development 단계로 왔으면, 다시 Specification 단계로 되돌아가지 않는다!)
    >> 완전히 단계가 딱 나누어져 있는 개발 프로세스 모델! 각 단계가 나누어져서 구별이 된다~
    
  -> Incremental Development(점진적, 단계적 개발)
    >> Specificatoin / Development / Validation이 한 템포에 같이 진행된다. 
    >> 1번기능, 2번기능 3번기능 이 있으면, 1번 기능만 만들고 출시하고, 이후 2,3번은 나중에 개발해서 업데이트 하는 식이라,
       Plan-Driven이라고도 할 수 있고, Agile이라고도 할 수 있다. 1번 기능 출시할 때는 Waterfall model 처럼 구현했을 것이다.
       그러면 그 상황안에서만 Plan-Driven처럼 개발한 것이다. 하지만, 1번만 개발하기 위한 걔획만 짰으니 Agile이라고도 할 수 있는
       것이다. 이후 2,3번도 개발해야 하기 때문이다. 
    >> 어떤 측면에서 보는지에 따라 Plan-Driven이라고도 할 수 있고, Agile이라고도 할 수 있다. 
    
  -> Integration & Configuration  
    >> 결국 일부를 만들어 놓고, "통합" 하는 것이기 때문에, 일부를 만들때는 Plan-Driven / 전체로 볼때는 Agile 이라고 할 수 있다.
    >> 입맛에 맞는 대로 부르는 느낌인 것이다. 
    >> Configuration(환경 설정) 하는 부분도 마찬가지이다. 
       
  -> ( 결국 큰 프로젝트에서는, 해당 모델들을 조화롭게 사용해서 개발하게 될 것이다 )
  
** WaterFall Model : 

  -> Requirements & Definition----- 
            ^                      |
            |                      |
            |                      |
            |        System & Software Design---------
            |                      ^                 |
            |                      |                 |
            |                      |                 |
            |                      |                 |
            |                      |       Implementation & Unit Testing ----------
            |                      |                 ^                            |  
            |                      |                 |                            |
            |                      |                 |                            |
            |                      |                 |                            |    
            |                      |                 |                  Integration & System Testing---
            |                      |                 |                            ^                   |                                                                      
            |                      |                 |                            |                   |
            |                      |                 |                            |                   |
            |                      |                 |                            |                   |
            ------------------------------------------------------------------------------  Operation & Maintenance
                                                                    
                                                                    
    >> Requirement : Requirement Analysis라고도 많이 이야기함. (요구사항 분석). 실제로 고객이 어떤 소프트웨어를 원하는지
                     요구사항을 분석해야 한다는 것임. 요구사항을 분석해서 나오는 결과가 "스펙"이다.
                     이 단계에 오게 되면 Requirement Define 역시 되는 것이다. Specification Document(설계서) 역시 여기서
                     나오게 될 것이다. 
                     
    >> System & Software Design : 위의 결과물, 스펙을 보고 어떻게 디자인되어야 하는지가 나올 것이다. 그 과정을 수행한다. 
                                  이 단계에서 역시 Software Design Document가 나온다. 다 문서화해서 나옴. 
    
    >> Implementation & Unit Testing : 구현하고, Unit 테스팅하는 것.  구현할 때 보통 Unit(단위) Testing을 같이 수행하게 된다. 
                                       대체로 여기서 말하는 Unit이란, Java의 Class 단위를 말한다. 최소한 클래스 단위에서는 테스팅이 
                                       해당 단계에서 끝나야 된다는 것이다. 그렇다면 그 클래스 하나만 쓸 때는, 해당 클래스가 이상이 있는지
                                       없는지 파악할 수 있을 것이다. C에서 Unit이란, Function 단위를 말하는 것이 될 것이다. 
    
    >> Integration & System Testing : 이 단계가 본격적인 테스팅 단계이다. Unit을 같이 유기적으로 써 보면서, 이렇게 유기적으로 사용했을 때 
                                      문제가 되는지 안되는지를 확인하는 것이 Integration & System Testing이라고 보면 될 것이다. 
                    
    >> Operation & Maintenance : 시운전 해 보는 것이다. 이후 유지보수 함. 이 유지보수에도 3가지 종류가 있다! (기능상의 추가 / 수정 / 삭제 )
         
         
 -> 상세 설명 :         
    >> 맨 처음 요구사항에서 안맞으면, 요구 사항으로 다시 이동할 수도 있다. 만약에 설계(Design)이 잘못 되었다면, 설계도 고치러 다시 올라갈 수 있다.
       구현상 어떤 problem이 있다면 구현 단계로 다시 올라간다.  WaterFall 모델에서는, 어디 단계에 있든 끝까지 가야 한다. 그런 다음 다시 내려가는 
       것이다. 
    
    >> 이 단계 자체는 다른 방법론에서도 똑같이 등장한다. 하지만, 다른 방법론과는 다르게 WaterFall Model에서는 이 단계를 명확히 구분해서 개발하는 반면에
       다른 방법론에서는 단계의 경계가 모호하다. 다른 방법론에서는 스펙을 정의하면서 설계할 수도 있고, 설계하면서 구현할 수도 있는 것이다. 
       하지만, WaterFall Model(Plan-Driven 방식)에서는 다 구분해서 진행을 한다.  
                                 
    >> 요구사항, 설계, 구현상의 변화가 일어나게 되면 대응하기 상당히 어렵다. 끝까지 돌려보고 나서 그 다음에 올라오기 때문에, 요구사항이 바뀌면 그 아래도
       쭉 따라 바뀌기 때문이다. 그래서 이런 변화가 자주 일어나는 개발에서는 WaterFall Model을 적용하기 어렵다. 이렇기 때문에, 고객이 새로 Requirement를 
       바꾸는 것이 어렵다.  
       
    >> "Inflexable Partitioning" : Waterfall Model 은 Plan-Driven이기 때문에 처음부터 전체 소프트웨어에 대한 구조설계를 다 하고 시작을 하는 것이다. 
                                   핵심이 되는 부분만 Partitioning 해서 먼저 진행을 하겠다! 하는 것이 용납이 되지 않는 구조.
                                   "Distinct stage"(구분되는 스테이지) (1단계로 이거 하고, 2단계로 저걸 하겠다) 하는 것이 허용되지 않는다. 
                                   그렇기 때문에,  1~10까지 있다면 최소 해당 소프트웨어 개발에 대해 8~9 정도는 아는 단계에서 이런 개발 방법을 사용한다. 
                                   
    >> 이렇게 변화에 대해 민감하지 못한 방법론이기 때문에, 좋지 못한 개발 방법론이 아닌가 하는 생각을 할 수 있다. 하지만, 대규모 프로젝트, 큰 시스템 규모에서는 
       Waterfall 모델을 적용하지 않으면 개발 자체가 엉망진창이 될 수 있다. 해야 할 공정이 굉장히 많기 때문에, 많은 만큼 계획을 잡고 그에 대한 설계를 다 해둔 
       다음에 진행을 해야, 뒤에 가서 문제가 생기지 않는 것이다. 그렇기에 규모가 큰 개발에서 WaterFall Model을 많이 사용한다. 반면, 단기간 개발을 해야 하고 
       보다 작은 중간 규모 급들은 다 Agile 형식을 많이 취하게 된다. 
       
    >> 장점 : 역시 문제 생길 소지가 적다. / 단점 : 개발기간이 다른 개발 방법론에 비해 상당히 길다. (기본 1~2년)   
       ex) 양이 많은 과목일수록 벼락치기가 힘들 것이다. 시간적 제한이 있으면 그 제한에 따라 계획서를 짜고 미리미리 공부를 조금씩 해 두어야 나중에 그 과목에 대한 
           시험을 잘 칠수 있을 것이다. 미리 준비를 할 수 있는 것이다. 
           
       >>>> 프로젝트 덩치가 커지다 보면, 전에 했던 것을 까먹기 마련이다. 사람의 한계이다. 그러다 보니, 문서를 다 남기고 개발 단계를 거쳐가면서 개발을 한다면, 
            "어디까지 했으면, 전 단계는 안 봐도 되는" 장점이 생긴다. 그렇게 다음으로 계속 넘어가는 것이다. 
            굉장히 큰 시스템을 만들 때 그래서 유리해진다. (like 무기 체계 개발)
            
       ex2) 미사일을 개발한다고 해 보자. 미사일 하나를 만들면, 그거 하나 만든다고 끝나는 것이 아니다. 미사일을 실을 수송기, 또는 함 같은 곳에도 공간을 만들고 
            자동 제어 장치도 만들어야 한다. 그리고 관제실 또는 통신 지휘부에서도 그 정보를 계속해서 알고 있어야 하고, 반대로 통신 지휘부에서도 해당 미사일에 
            명령을 내릴 수 있어야 하는 등의 제반 사항들이 다 따라온다. 
            그렇기에, 이런것들을 유지보수하는데 있어서도 주먹구구식으로 하는 것은 불가능하다. 
                
 **                     
                    
                    
                    
