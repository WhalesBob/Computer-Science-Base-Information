< 2장 : Software Processes >

* Topics Covered
- Software Process Model
- Process 활동(Activities)
- 변화가 생겼을 때 Changing
- Process Improvement


** Software Process(개발 프로세스)
  -> 소프트웨어 개발 시 필요한, 정형화된 활동
    >> 건물 짓는 것에 많이 비유한다. 단순히 "아파트를 짓는다" 는것이 아닌, "방은 몇 개인지 등등"을 정하고 나서 건축을 하는 느낌이다. 
  
  -> Specification : 
    >> 위에서 말한 소프트웨어의 "스펙"을 정하는 것. 가급적 상세하게!
  
  -> Development(Design and Implementation) : 
    >> 위에서 말한 해당 스펙을 가지고, 세세한 "디자인" 을 먼저 진행한다! (디자인 설계 단계)
    >> 위에서 말한 디자인 단계가 전부 이루어지고 나면, 그제서야 Implementation(구현)을 하는 것이다. ( 설계대로! )
     
  -> Validation : (소비자가 원하는 모습과 일치하는지! (1장에서 상세히 정리)(복붙하기))
  
  -> Evolution : (상황, 정보의 변화에 맞게 새로 evolution!  (1장에서 상세히 정리)(복붙하기))
  
   -> 스펙이 상세할수록 디자인하기 쉽고, 디자인이 상세할수록 구현하기는 쉽다. 하지만, 상세하지 않다고 해서 디자인이 안 되거나 
      구현이 안 되는 것은 아니다! 
      
** Plan-driven and Agile Process
  -> 개발을 할 때 크게 두 가지 방법으로 나눌 수 있다! ( Plan-Driven vs Agile )
  -> Plan-Driven : 
    >> 말 그대로 계획이 모두 정해져 있는 것.
    >> 만약 처음에 1년 동안 개발한다고 정해 두었다면, 1년치 계획을 다 짜는 것이다. 그리고 수행하는 것.
    >> 뭔가 다 정해져서, 바뀔 일이 없을 때 해당 방법을 사용하는 것이 유리하다. 
    >> ex) 방산 프로젝트 / 한번 만들어 본 것을 다시 만들 때(이미 어떻게 흘러가는지 계획이 다 있는 경우)
    
  -> Agile : 
    >> 딱히 엄청 커다란 계획같은 것은 없다. 단지 계획은 그냥 Incremental(점진적으로) 하는 것.
    >> 개발하다 보면 뭔가 또 바뀌는 사항 같은 것들이 있을 것이다!
    >> 바뀌면 그에 맞춰서 또다시 계획을 짜고 개발하는 것을 무한 반복하는 것이다.
    >> 이러다가 또 고객의 요구사항에 따라 계속 반복하는 것임.
    >> 요구사항이나, 상황이 분명히 바뀔 것 같을 때 사용하는 것이 유리한 개발 방법이다. (해당 변경건으로 인해 계획 내용이 바뀔 것이기 때문)
    >> 나쁘게 말한다면, 그냥 마구잡이로 개발하는 것. 일단 고객이 있으니, 어떻게든 개발해보고 고객에게 보여주고, 아니라고 하면 그에 맞춰서 
       또 개발하는 것이다. 
    >> ex) Plan-driven 의 사례가 아닌 대부분의 사례
       
  -> (실제로는, 실제적인 개발 프로세스에는 두 가지 개발 방법의 요소가 둘 다 섞여 있는 경우가 많다. 두가지 방법 다 맞는, 혹은 틀린 방법은 
      아니다. 상황에 따라 두가지 방법 중 더 잘 맞는 방법을 선택하는 것이다.)
      
 ** 개발 프로세스 모델
 
  -> Waterfall model : 
    >> Plan-Driven 개발방법의 대표적인 사례. 폭포수가 아래로만 쭉 떨어지듯이, 거꾸로 올라가지 않고 한 방향으로 쭉 진행하는 모델
    >> Specification / Development / Validation 단계별로, 한 단계를 지났으면 그 단계로 다시 올라가지 않는다. 
      (Specifiation이 끝나고 Development 단계로 왔으면, 다시 Specification 단계로 되돌아가지 않는다!)
    >> 완전히 단계가 딱 나누어져 있는 개발 프로세스 모델! 각 단계가 나누어져서 구별이 된다~
    
  -> Incremental Development(점진적, 단계적 개발)
    >> Specificatoin / Development / Validation이 한 템포에 같이 진행된다. 
    >> 1번기능, 2번기능 3번기능 이 있으면, 1번 기능만 만들고 출시하고, 이후 2,3번은 나중에 개발해서 업데이트 하는 식이라,
       Plan-Driven이라고도 할 수 있고, Agile이라고도 할 수 있다. 1번 기능 출시할 때는 Waterfall model 처럼 구현했을 것이다.
       그러면 그 상황안에서만 Plan-Driven처럼 개발한 것이다. 하지만, 1번만 개발하기 위한 걔획만 짰으니 Agile이라고도 할 수 있는
       것이다. 이후 2,3번도 개발해야 하기 때문이다. 
    >> 어떤 측면에서 보는지에 따라 Plan-Driven이라고도 할 수 있고, Agile이라고도 할 수 있다. 
    
  -> Integration & Configuration  
    >> 결국 일부를 만들어 놓고, "통합" 하는 것이기 때문에, 일부를 만들때는 Plan-Driven / 전체로 볼때는 Agile 이라고 할 수 있다.
    >> 입맛에 맞는 대로 부르는 느낌인 것이다. 
    >> Configuration(환경 설정) 하는 부분도 마찬가지이다. 
       
  -> ( 결국 큰 프로젝트에서는, 해당 모델들을 조화롭게 사용해서 개발하게 될 것이다 )
  
** WaterFall Model : 

  -> Requirements & Definition----- 
            ^                      |
            |                      |
            |                      |
            |        System & Software Design---------
            |                      ^                 |
            |                      |                 |
            |                      |                 |
            |                      |                 |
            |                      |       Implementation & Unit Testing ----------
            |                      |                 ^                            |  
            |                      |                 |                            |
            |                      |                 |                            |
            |                      |                 |                            |    
            |                      |                 |                  Integration & System Testing---
            |                      |                 |                            ^                   |                                                                      
            |                      |                 |                            |                   |
            |                      |                 |                            |                   |
            |                      |                 |                            |                   |
            ------------------------------------------------------------------------------  Operation & Maintenance
                                                                    
                                                                    
    >> Requirement : Requirement Analysis라고도 많이 이야기함. (요구사항 분석). 실제로 고객이 어떤 소프트웨어를 원하는지
                     요구사항을 분석해야 한다는 것임. 요구사항을 분석해서 나오는 결과가 "스펙"이다.
                     이 단계에 오게 되면 Requirement Define 역시 되는 것이다. Specification Document(설계서) 역시 여기서
                     나오게 될 것이다. 
                     
    >> System & Software Design : 위의 결과물, 스펙을 보고 어떻게 디자인되어야 하는지가 나올 것이다. 그 과정을 수행한다. 
                                  이 단계에서 역시 Software Design Document가 나온다. 다 문서화해서 나옴. 
    
    >> Implementation & Unit Testing : 구현하고, Unit 테스팅하는 것.  구현할 때 보통 Unit(단위) Testing을 같이 수행하게 된다. 
                                       대체로 여기서 말하는 Unit이란, Java의 Class 단위를 말한다. 최소한 클래스 단위에서는 테스팅이 
                                       해당 단계에서 끝나야 된다는 것이다. 그렇다면 그 클래스 하나만 쓸 때는, 해당 클래스가 이상이 있는지
                                       없는지 파악할 수 있을 것이다. C에서 Unit이란, Function 단위를 말하는 것이 될 것이다. 
    
    >> Integration & System Testing : 이 단계가 본격적인 테스팅 단계이다. Unit을 같이 유기적으로 써 보면서, 이렇게 유기적으로 사용했을 때 
                                      문제가 되는지 안되는지를 확인하는 것이 Integration & System Testing이라고 보면 될 것이다. 
                    
    >> Operation & Maintenance : 시운전 해 보는 것이다. 이후 유지보수 함. 이 유지보수에도 3가지 종류가 있다! (기능상의 추가 / 수정 / 삭제 )
         
         
 -> 상세 설명 :         
    >> 맨 처음 요구사항에서 안맞으면, 요구 사항으로 다시 이동할 수도 있다. 만약에 설계(Design)이 잘못 되었다면, 설계도 고치러 다시 올라갈 수 있다.
       구현상 어떤 problem이 있다면 구현 단계로 다시 올라간다.  WaterFall 모델에서는, 어디 단계에 있든 끝까지 가야 한다. 그런 다음 다시 내려가는 
       것이다. 
    
    >> 이 단계 자체는 다른 방법론에서도 똑같이 등장한다. 하지만, 다른 방법론과는 다르게 WaterFall Model에서는 이 단계를 명확히 구분해서 개발하는 반면에
       다른 방법론에서는 단계의 경계가 모호하다. 다른 방법론에서는 스펙을 정의하면서 설계할 수도 있고, 설계하면서 구현할 수도 있는 것이다. 
       하지만, WaterFall Model(Plan-Driven 방식)에서는 다 구분해서 진행을 한다.  
                                 
    >> 요구사항, 설계, 구현상의 변화가 일어나게 되면 대응하기 상당히 어렵다. 끝까지 돌려보고 나서 그 다음에 올라오기 때문에, 요구사항이 바뀌면 그 아래도
       쭉 따라 바뀌기 때문이다. 그래서 이런 변화가 자주 일어나는 개발에서는 WaterFall Model을 적용하기 어렵다. 이렇기 때문에, 고객이 새로 Requirement를 
       바꾸는 것이 어렵다.  
       
    >> "Inflexable Partitioning" : Waterfall Model 은 Plan-Driven이기 때문에 처음부터 전체 소프트웨어에 대한 구조설계를 다 하고 시작을 하는 것이다. 
                                   핵심이 되는 부분만 Partitioning 해서 먼저 진행을 하겠다! 하는 것이 용납이 되지 않는 구조.
                                   "Distinct stage"(구분되는 스테이지) (1단계로 이거 하고, 2단계로 저걸 하겠다) 하는 것이 허용되지 않는다. 
                                   그렇기 때문에,  1~10까지 있다면 최소 해당 소프트웨어 개발에 대해 8~9 정도는 아는 단계에서 이런 개발 방법을 사용한다. 
                                   
    >> 이렇게 변화에 대해 민감하지 못한 방법론이기 때문에, 좋지 못한 개발 방법론이 아닌가 하는 생각을 할 수 있다. 하지만, 대규모 프로젝트, 큰 시스템 규모에서는 
       Waterfall 모델을 적용하지 않으면 개발 자체가 엉망진창이 될 수 있다. 해야 할 공정이 굉장히 많기 때문에, 많은 만큼 계획을 잡고 그에 대한 설계를 다 해둔 
       다음에 진행을 해야, 뒤에 가서 문제가 생기지 않는 것이다. 그렇기에 규모가 큰 개발에서 WaterFall Model을 많이 사용한다. 반면, 단기간 개발을 해야 하고 
       보다 작은 중간 규모 급들은 다 Agile 형식을 많이 취하게 된다. 
       
    >> 장점 : 역시 문제 생길 소지가 적다. / 단점 : 개발기간이 다른 개발 방법론에 비해 상당히 길다. (기본 1~2년)   
       ex) 양이 많은 과목일수록 벼락치기가 힘들 것이다. 시간적 제한이 있으면 그 제한에 따라 계획서를 짜고 미리미리 공부를 조금씩 해 두어야 나중에 그 과목에 대한 
           시험을 잘 칠수 있을 것이다. 미리 준비를 할 수 있는 것이다. 
           
       >>>> 프로젝트 덩치가 커지다 보면, 전에 했던 것을 까먹기 마련이다. 사람의 한계이다. 그러다 보니, 문서를 다 남기고 개발 단계를 거쳐가면서 개발을 한다면, 
            "어디까지 했으면, 전 단계는 안 봐도 되는" 장점이 생긴다. 그렇게 다음으로 계속 넘어가는 것이다. 
            굉장히 큰 시스템을 만들 때 그래서 유리해진다. (like 무기 체계 개발)
            
       ex2) 미사일을 개발한다고 해 보자. 미사일 하나를 만들면, 그거 하나 만든다고 끝나는 것이 아니다. 미사일을 실을 수송기, 또는 함 같은 곳에도 공간을 만들고 
            자동 제어 장치도 만들어야 한다. 그리고 관제실 또는 통신 지휘부에서도 그 정보를 계속해서 알고 있어야 하고, 반대로 통신 지휘부에서도 해당 미사일에 
            명령을 내릴 수 있어야 하는 등의 제반 사항들이 다 따라온다. 
            그렇기에, 이런것들을 유지보수하는데 있어서도 주먹구구식으로 하는 것은 불가능하다. 
                
 ** Incremental Development
  -> Specification & Development & Validation 이 유기적으로 왔다갔다 하게 된다. 
    >> 스펙 세웠다가 개발해보고, 바꾸고 하다가 개발된 거 또 테스트해보고, 왔다갔다 한다
    
  -> 그러다가 Initial Version 나오게 되면 Validation 할 수 있는 것이다. 그럼 그것으로 피드백 받고 다시 돌아가서 반복하며, 그 다음 버전을 만들수 있는 것이다.
     그러면 두 번째 버전 나오는 것임. 이렇게 3,4,5번째 버전이 계속 나오기 시작한다. 
     
  -> 이 과정 속에서 최종적으로 나오는 것이 마지막 버전이 되며, 마지막 버전까지 나오면 끝난 것이다.
  
  -> 해당 세세한 과정 안에서는 Waterfall 처럼 개발하기는 할 것이다. 하지만, 실제로 Waterfall 모델이라고 하기는 좀 그렇다. 각 단계를 왔다갔다 하는 것이라 그렇다. 
  
  -> Incremental Development의 장점 :
  
    >> 변화에 민감하게 대응하기 위해 Incremental Development 방식을 취하는 것이다. (Waterfall 모델의 방식이 변화에 상당히 약하기 때문에 그렇다)
       고객의 눈에 보이는 것을 빨리빨리 만들어내야 고객이 보면서 피드백을 줄 수 있는 것이다. 
       
    >> 유용한 Software를 엄청 빠르게 Delivery 하고 Deployment하는 것이 가능하다! Delivery와 개발이 조금 더 빨리빨리 필요할 때는 이런 개발 환경을 많이 쓴다. 
       (빨리빨리 Running Version을 만들어 내면서 Delivery(Play Store에 올리는 등))
  
    >> 과정같은 것들이 눈에 잘 안 보여서 이것저것 다 하는것 처럼 보이기도 한다. 
    >> 결과물이 나온 것을 가지고 피드백 주고, 다시 하면서 상호작용이 계속 일어나는 상태임.
                    
  -> Incremental Development의 단점 :                   
    >> Waterfall 방법에 비해서, 프로세스(얼마나 진행되었는지) 가 상대적으로 보이지 않는다.
    (WaterFall 방법은 전체적인 계획이 있어서, 진척이 얼마나 되었는지가 확인이 쉽다. 하지만, Incremental 방법 같은 경우에는 개발자 스스로도 얼마만큼 
     진행되었는지 알기 어렵다. 새로운 기능을 넣고 넣으며, 고객이 만족할때가지 개발을 진행해야 하기 때문이다. 진척률을 파악하기가 대단히 어렵다! )
     
    >> 규모가 커지면 커질수록, 해당 방법론으로는 기능을 추가하는게 굉장히 어려워진다. 맨 처음에는 기능을 추가할 것을 고려하지 않고, 짜는데 급급하게 
       코딩을 해 놓았기 때문에, 대체로 구현되고 보여주는 것 위주로 짜게 될 것이다. Unit들 간의 의존성이 높게 코딩해 놓았는데, A,B 기능 뒤에 C를 넣으려니
       A도 그에 맞게 새로 짜야 하고, B도 그에 맞게 새로 짜다보면 Refactoring 하는데 시간과 돈이 많이 든다. 
       맨 처음에 아무리 잘 정해놨어도, 그 뒤에 뭐가 들어올지 예상할 수 없는 상황이기 때문이다. 
       
       아무리 위의 단점을 막는게 개발자의 역량이라지만, 개발자가 하나부터 100까지 모두 고려할 수는 없는 노릇이다. 
       그렇기 때문에 대체로 처음부터 계획을 안 잡고 중간 중간에 추가가 되게 되면, 코드를 반드시 다시 한번 정리해 줘야 하는 과정이 필요해지고,
       이미 양이 너무 많고 규모가 커진 프로젝트에서는 그 비용이 어마무시하게 커지게 된다. 
       >>>> 그렇기에 WaterFall 모델이 Large System에서는 더 유리한 것이다. 
       >>>> Incremental 은 Middle급 정도 되는 프로젝트에서 사용한다. 
       
       
       
** Integration & Configuration        
  
  -> About Reuse : 
    >> 요즘은 Reuse하는 것이 거의 Standard가 되기는 했지만, 만들려고 하는 System에 특화된 형태로 잘 Customizing해야 의미가 있는 것이다. 
       그냥 갖다쓰게 되면 의미가 없다! 
      
    >> 시스템에 적합하게 바꾸는 작업이 이루어지지 않으면, 그 이상의 프로그램 규모가 늘어나지 않는다 )
    >> ex) sns 로그인하는 기능 / 전자결제 / 휴대폰 인증
           (이런것들을 일일이 하나하나 직접 구현하고자 하면 엄청난 코드 양이 필요할 것이다. 구현하는 것만 문제가 되는 것이 아니라, 사업자 인증
            기관등록 등등 처리해야 할 일이 너무 많다. 그냥 Reuse 하면 된다! 단, 최적화해서 ) 
  
  -> Types of Reusable Software  
    >> .NET / jdk&jre 같은 프레임워크를 잘 사용해서, 프레임워크에서 주는 API를 잘 사용하며, 이미 사람들이 많이 사용하는 코드를 많이 Reuse 하자!
        (프레임워크를 잘 쓰자)(오픈소스도 마찬가지! 잘 쓰자!)
    >> ex) 안드로이드 개발할 때, 화면 미는 기술을 일일이 구현하고있으면, 엄청 어렵기도 하고, 코드 양도 상당히 많다. 그냥 안드로이드 스튜디오에서의 
           SDK에 있는, 구현된 API들을 잘 사용하도록 하자!
            
     
** Reuse-Oriented Software Engineering (그림 

    
    
    
    
    
    
    
    
