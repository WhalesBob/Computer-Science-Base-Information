< 2장 : Software Processes >

* Topics Covered
- Software Process Model
- Process 활동(Activities)
- 변화가 생겼을 때 Changing
- Process Improvement


** Software Process(개발 프로세스)
  -> 소프트웨어 개발 시 필요한, 정형화된 활동
    >> 건물 짓는 것에 많이 비유한다. 단순히 "아파트를 짓는다" 는것이 아닌, "방은 몇 개인지 등등"을 정하고 나서 건축을 하는 느낌이다. 
  
  -> Specification : 
    >> 위에서 말한 소프트웨어의 "스펙"을 정하는 것. 가급적 상세하게!
  
  -> Development(Design and Implementation) : 
    >> 위에서 말한 해당 스펙을 가지고, 세세한 "디자인" 을 먼저 진행한다! (디자인 설계 단계)
    >> 위에서 말한 디자인 단계가 전부 이루어지고 나면, 그제서야 Implementation(구현)을 하는 것이다. ( 설계대로! )
     
  -> Validation : (소비자가 원하는 모습과 일치하는지! (1장에서 상세히 정리)(복붙하기))
  
  -> Evolution : (상황, 정보의 변화에 맞게 새로 evolution!  (1장에서 상세히 정리)(복붙하기))
  
   -> 스펙이 상세할수록 디자인하기 쉽고, 디자인이 상세할수록 구현하기는 쉽다. 하지만, 상세하지 않다고 해서 디자인이 안 되거나 
      구현이 안 되는 것은 아니다! 
      
** Plan-driven and Agile Process
  -> 개발을 할 때 크게 두 가지 방법으로 나눌 수 있다! ( Plan-Driven vs Agile )
  -> Plan-Driven : 
    >> 말 그대로 계획이 모두 정해져 있는 것.
    >> 만약 처음에 1년 동안 개발한다고 정해 두었다면, 1년치 계획을 다 짜는 것이다. 그리고 수행하는 것.
    >> 뭔가 다 정해져서, 바뀔 일이 없을 때 해당 방법을 사용하는 것이 유리하다. 
    >> ex) 방산 프로젝트 / 한번 만들어 본 것을 다시 만들 때(이미 어떻게 흘러가는지 계획이 다 있는 경우)
    
  -> Agile : 
    >> 딱히 엄청 커다란 계획같은 것은 없다. 단지 계획은 그냥 Incremental(점진적으로) 하는 것.
    >> 개발하다 보면 뭔가 또 바뀌는 사항 같은 것들이 있을 것이다!
    >> 바뀌면 그에 맞춰서 또다시 계획을 짜고 개발하는 것을 무한 반복하는 것이다.
    >> 이러다가 또 고객의 요구사항에 따라 계속 반복하는 것임.
    >> 요구사항이나, 상황이 분명히 바뀔 것 같을 때 사용하는 것이 유리한 개발 방법이다. (해당 변경건으로 인해 계획 내용이 바뀔 것이기 때문)
    >> 나쁘게 말한다면, 그냥 마구잡이로 개발하는 것. 일단 고객이 있으니, 어떻게든 개발해보고 고객에게 보여주고, 아니라고 하면 그에 맞춰서 
       또 개발하는 것이다. 
    >> ex) Plan-driven 의 사례가 아닌 대부분의 사례
       
  -> (실제로는, 실제적인 개발 프로세스에는 두 가지 개발 방법의 요소가 둘 다 섞여 있는 경우가 많다. 두가지 방법 다 맞는, 혹은 틀린 방법은 
      아니다. 상황에 따라 두가지 방법 중 더 잘 맞는 방법을 선택하는 것이다.)
      
 ** 개발 프로세스 모델
 
  -> Waterfall model : 
    >> Plan-Driven 개발방법의 대표적인 사례. 폭포수가 아래로만 쭉 떨어지듯이, 거꾸로 올라가지 않고 한 방향으로 쭉 진행하는 모델
    >> Specification / Development / Validation 단계별로, 한 단계를 지났으면 그 단계로 다시 올라가지 않는다. 
      (Specifiation이 끝나고 Development 단계로 왔으면, 다시 Specification 단계로 되돌아가지 않는다!)
    >> 완전히 단계가 딱 나누어져 있는 개발 프로세스 모델! 각 단계가 나누어져서 구별이 된다~
    
  -> Incremental Development(점진적, 단계적 개발)
    >> Specificatoin / Development / Validation이 한 템포에 같이 진행된다. 
    >> 1번기능, 2번기능 3번기능 이 있으면, 1번 기능만 만들고 출시하고, 이후 2,3번은 나중에 개발해서 업데이트 하는 식이라,
       Plan-Driven이라고도 할 수 있고, Agile이라고도 할 수 있다. 1번 기능 출시할 때는 Waterfall model 처럼 구현했을 것이다.
       그러면 그 상황안에서만 Plan-Driven처럼 개발한 것이다. 하지만, 1번만 개발하기 위한 걔획만 짰으니 Agile이라고도 할 수 있는
       것이다. 이후 2,3번도 개발해야 하기 때문이다. 
    >> 어떤 측면에서 보는지에 따라 Plan-Driven이라고도 할 수 있고, Agile이라고도 할 수 있다. 
    
  -> Integration & Configuration  
    >> 결국 일부를 만들어 놓고, "통합" 하는 것이기 때문에, 일부를 만들때는 Plan-Driven / 전체로 볼때는 Agile 이라고 할 수 있다.
    >> 입맛에 맞는 대로 부르는 느낌인 것이다. 
    >> Configuration(환경 설정) 하는 부분도 마찬가지이다. 
       
  -> ( 결국 큰 프로젝트에서는, 해당 모델들을 조화롭게 사용해서 개발하게 될 것이다 )
  
** WaterFall Model : 

  -> Requirements & Definition----- 
            ^                      |
            |                      |
            |                      |
            |        System & Software Design---------
            |                      ^                 |
            |                      |                 |
            |                      |                 |
            |                      |                 |
            |                      |       Implementation & Unit Testing ----------
            |                      |                 ^                            |  
            |                      |                 |                            |
            |                      |                 |                            |
            |                      |                 |                            |    
            |                      |                 |                  Integration & System Testing---
            |                      |                 |                            ^                   |                                                                      
            |                      |                 |                            |                   |
            |                      |                 |                            |                   |
            |                      |                 |                            |                   |
            ------------------------------------------------------------------------------  Operation & Maintenance
                                                                    
                                                                    
    >> Requirement : Requirement Analysis라고도 많이 이야기함. (요구사항 분석). 실제로 고객이 어떤 소프트웨어를 원하는지
                     요구사항을 분석해야 한다는 것임. 요구사항을 분석해서 나오는 결과가 "스펙"이다.
                     이 단계에 오게 되면 Requirement Define 역시 되는 것이다. Specification Document(설계서) 역시 여기서
                     나오게 될 것이다. 
                     
    >> System & Software Design : 위의 결과물, 스펙을 보고 어떻게 디자인되어야 하는지가 나올 것이다. 그 과정을 수행한다. 
                                  이 단계에서 역시 Software Design Document가 나온다. 다 문서화해서 나옴. 
    
    >> Implementation & Unit Testing : 구현하고, Unit 테스팅하는 것.  구현할 때 보통 Unit(단위) Testing을 같이 수행하게 된다. 
                                       대체로 여기서 말하는 Unit이란, Java의 Class 단위를 말한다. 최소한 클래스 단위에서는 테스팅이 
                                       해당 단계에서 끝나야 된다는 것이다. 그렇다면 그 클래스 하나만 쓸 때는, 해당 클래스가 이상이 있는지
                                       없는지 파악할 수 있을 것이다. C에서 Unit이란, Function 단위를 말하는 것이 될 것이다. 
    
    >> Integration & System Testing : 이 단계가 본격적인 테스팅 단계이다. Unit을 같이 유기적으로 써 보면서, 이렇게 유기적으로 사용했을 때 
                                      문제가 되는지 안되는지를 확인하는 것이 Integration & System Testing이라고 보면 될 것이다. 
                    
    >> Operation & Maintenance : 시운전 해 보는 것이다. 이후 유지보수 함. 이 유지보수에도 3가지 종류가 있다! (기능상의 추가 / 수정 / 삭제 )
         
         
 -> 상세 설명 :         
    >> 맨 처음 요구사항에서 안맞으면, 요구 사항으로 다시 이동할 수도 있다. 만약에 설계(Design)이 잘못 되었다면, 설계도 고치러 다시 올라갈 수 있다.
       구현상 어떤 problem이 있다면 구현 단계로 다시 올라간다.  WaterFall 모델에서는, 어디 단계에 있든 끝까지 가야 한다. 그런 다음 다시 내려가는 
       것이다. 
    
    >> 이 단계 자체는 다른 방법론에서도 똑같이 등장한다. 하지만, 다른 방법론과는 다르게 WaterFall Model에서는 이 단계를 명확히 구분해서 개발하는 반면에
       다른 방법론에서는 단계의 경계가 모호하다. 다른 방법론에서는 스펙을 정의하면서 설계할 수도 있고, 설계하면서 구현할 수도 있는 것이다. 
       하지만, WaterFall Model(Plan-Driven 방식)에서는 다 구분해서 진행을 한다.  
                                 
    >> 요구사항, 설계, 구현상의 변화가 일어나게 되면 대응하기 상당히 어렵다. 끝까지 돌려보고 나서 그 다음에 올라오기 때문에, 요구사항이 바뀌면 그 아래도
       쭉 따라 바뀌기 때문이다. 그래서 이런 변화가 자주 일어나는 개발에서는 WaterFall Model을 적용하기 어렵다. 이렇기 때문에, 고객이 새로 Requirement를 
       바꾸는 것이 어렵다.  
       
    >> "Inflexable Partitioning" : Waterfall Model 은 Plan-Driven이기 때문에 처음부터 전체 소프트웨어에 대한 구조설계를 다 하고 시작을 하는 것이다. 
                                   핵심이 되는 부분만 Partitioning 해서 먼저 진행을 하겠다! 하는 것이 용납이 되지 않는 구조.
                                   "Distinct stage"(구분되는 스테이지) (1단계로 이거 하고, 2단계로 저걸 하겠다) 하는 것이 허용되지 않는다. 
                                   그렇기 때문에,  1~10까지 있다면 최소 해당 소프트웨어 개발에 대해 8~9 정도는 아는 단계에서 이런 개발 방법을 사용한다. 
                                   
    >> 이렇게 변화에 대해 민감하지 못한 방법론이기 때문에, 좋지 못한 개발 방법론이 아닌가 하는 생각을 할 수 있다. 하지만, 대규모 프로젝트, 큰 시스템 규모에서는 
       Waterfall 모델을 적용하지 않으면 개발 자체가 엉망진창이 될 수 있다. 해야 할 공정이 굉장히 많기 때문에, 많은 만큼 계획을 잡고 그에 대한 설계를 다 해둔 
       다음에 진행을 해야, 뒤에 가서 문제가 생기지 않는 것이다. 그렇기에 규모가 큰 개발에서 WaterFall Model을 많이 사용한다. 반면, 단기간 개발을 해야 하고 
       보다 작은 중간 규모 급들은 다 Agile 형식을 많이 취하게 된다. 
       
    >> 장점 : 역시 문제 생길 소지가 적다. / 단점 : 개발기간이 다른 개발 방법론에 비해 상당히 길다. (기본 1~2년)   
       ex) 양이 많은 과목일수록 벼락치기가 힘들 것이다. 시간적 제한이 있으면 그 제한에 따라 계획서를 짜고 미리미리 공부를 조금씩 해 두어야 나중에 그 과목에 대한 
           시험을 잘 칠수 있을 것이다. 미리 준비를 할 수 있는 것이다. 
           
       >>>> 프로젝트 덩치가 커지다 보면, 전에 했던 것을 까먹기 마련이다. 사람의 한계이다. 그러다 보니, 문서를 다 남기고 개발 단계를 거쳐가면서 개발을 한다면, 
            "어디까지 했으면, 전 단계는 안 봐도 되는" 장점이 생긴다. 그렇게 다음으로 계속 넘어가는 것이다. 
            굉장히 큰 시스템을 만들 때 그래서 유리해진다. (like 무기 체계 개발)
            
       ex2) 미사일을 개발한다고 해 보자. 미사일 하나를 만들면, 그거 하나 만든다고 끝나는 것이 아니다. 미사일을 실을 수송기, 또는 함 같은 곳에도 공간을 만들고 
            자동 제어 장치도 만들어야 한다. 그리고 관제실 또는 통신 지휘부에서도 그 정보를 계속해서 알고 있어야 하고, 반대로 통신 지휘부에서도 해당 미사일에 
            명령을 내릴 수 있어야 하는 등의 제반 사항들이 다 따라온다. 
            그렇기에, 이런것들을 유지보수하는데 있어서도 주먹구구식으로 하는 것은 불가능하다. 
                
 ** Incremental Development
  -> Specification & Development & Validation 이 유기적으로 왔다갔다 하게 된다. 
    >> 스펙 세웠다가 개발해보고, 바꾸고 하다가 개발된 거 또 테스트해보고, 왔다갔다 한다
    
  -> 그러다가 Initial Version 나오게 되면 Validation 할 수 있는 것이다. 그럼 그것으로 피드백 받고 다시 돌아가서 반복하며, 그 다음 버전을 만들수 있는 것이다.
     그러면 두 번째 버전 나오는 것임. 이렇게 3,4,5번째 버전이 계속 나오기 시작한다. 
     
  -> 이 과정 속에서 최종적으로 나오는 것이 마지막 버전이 되며, 마지막 버전까지 나오면 끝난 것이다.
  
  -> 해당 세세한 과정 안에서는 Waterfall 처럼 개발하기는 할 것이다. 하지만, 실제로 Waterfall 모델이라고 하기는 좀 그렇다. 각 단계를 왔다갔다 하는 것이라 그렇다. 
  
  -> Incremental Development의 장점 :
  
    >> 변화에 민감하게 대응하기 위해 Incremental Development 방식을 취하는 것이다. (Waterfall 모델의 방식이 변화에 상당히 약하기 때문에 그렇다)
       고객의 눈에 보이는 것을 빨리빨리 만들어내야 고객이 보면서 피드백을 줄 수 있는 것이다. 
       
    >> 유용한 Software를 엄청 빠르게 Delivery 하고 Deployment하는 것이 가능하다! Delivery와 개발이 조금 더 빨리빨리 필요할 때는 이런 개발 환경을 많이 쓴다. 
       (빨리빨리 Running Version을 만들어 내면서 Delivery(Play Store에 올리는 등))
  
    >> 과정같은 것들이 눈에 잘 안 보여서 이것저것 다 하는것 처럼 보이기도 한다. 
    >> 결과물이 나온 것을 가지고 피드백 주고, 다시 하면서 상호작용이 계속 일어나는 상태임.
                    
  -> Incremental Development의 단점 :                   
    >> Waterfall 방법에 비해서, 프로세스(얼마나 진행되었는지) 가 상대적으로 보이지 않는다.
    (WaterFall 방법은 전체적인 계획이 있어서, 진척이 얼마나 되었는지가 확인이 쉽다. 하지만, Incremental 방법 같은 경우에는 개발자 스스로도 얼마만큼 
     진행되었는지 알기 어렵다. 새로운 기능을 넣고 넣으며, 고객이 만족할때가지 개발을 진행해야 하기 때문이다. 진척률을 파악하기가 대단히 어렵다! )
     
    >> 규모가 커지면 커질수록, 해당 방법론으로는 기능을 추가하는게 굉장히 어려워진다. 맨 처음에는 기능을 추가할 것을 고려하지 않고, 짜는데 급급하게 
       코딩을 해 놓았기 때문에, 대체로 구현되고 보여주는 것 위주로 짜게 될 것이다. Unit들 간의 의존성이 높게 코딩해 놓았는데, A,B 기능 뒤에 C를 넣으려니
       A도 그에 맞게 새로 짜야 하고, B도 그에 맞게 새로 짜다보면 Refactoring 하는데 시간과 돈이 많이 든다. 
       맨 처음에 아무리 잘 정해놨어도, 그 뒤에 뭐가 들어올지 예상할 수 없는 상황이기 때문이다. 
       
       아무리 위의 단점을 막는게 개발자의 역량이라지만, 개발자가 하나부터 100까지 모두 고려할 수는 없는 노릇이다. 
       그렇기 때문에 대체로 처음부터 계획을 안 잡고 중간 중간에 추가가 되게 되면, 코드를 반드시 다시 한번 정리해 줘야 하는 과정이 필요해지고,
       이미 양이 너무 많고 규모가 커진 프로젝트에서는 그 비용이 어마무시하게 커지게 된다. 
       >>>> 그렇기에 WaterFall 모델이 Large System에서는 더 유리한 것이다. 
       >>>> Incremental 은 Middle급 정도 되는 프로젝트에서 사용한다. 
       
       
       
** Integration & Configuration        
  
  -> About Reuse : 
    >> 요즘은 Reuse하는 것이 거의 Standard가 되기는 했지만, 만들려고 하는 System에 특화된 형태로 잘 Customizing해야 의미가 있는 것이다. 
       그냥 갖다쓰게 되면 의미가 없다! 
      
    >> 시스템에 적합하게 바꾸는 작업이 이루어지지 않으면, 그 이상의 프로그램 규모가 늘어나지 않는다 )
    >> ex) sns 로그인하는 기능 / 전자결제 / 휴대폰 인증
           (이런것들을 일일이 하나하나 직접 구현하고자 하면 엄청난 코드 양이 필요할 것이다. 구현하는 것만 문제가 되는 것이 아니라, 사업자 인증
            기관등록 등등 처리해야 할 일이 너무 많다. 그냥 Reuse 하면 된다! 단, 최적화해서 ) 
  
  -> Types of Reusable Software  
    >> .NET / jdk&jre 같은 프레임워크를 잘 사용해서, 프레임워크에서 주는 API를 잘 사용하며, 이미 사람들이 많이 사용하는 코드를 많이 Reuse 하자!
        (프레임워크를 잘 쓰자)(오픈소스도 마찬가지! 잘 쓰자!)
    >> ex) 안드로이드 개발할 때, 화면 미는 기술을 일일이 구현하고있으면, 엄청 어렵기도 하고, 코드 양도 상당히 많다. 그냥 안드로이드 스튜디오에서의 
           SDK에 있는, 구현된 API들을 잘 사용하도록 하자!
            
     
** Reuse-Oriented Software Engineering (Picture Ch2.1)
  1. Requirement Specification : 스펙 정하는 것. 앞에서 이미 나와있다. 
  2. 기존에 있던 것 탐색
    2.1 Software discovery : 이미 스펙에 해당하는 소프트웨어가 있는지 찾아보는 것. 
      (똑같은 것이 있으면 좋고, 비슷한 것이 있으면 거기서 조금 본인에게 맞게끔 바꾸면 된다)
    2.2 Software Evaluation : 있는 것을 추가로 개발하는 것. 
      (이미 찾은것 말고 자기자신이 만들어 놓은것이 있을수도 있음)
      
    
  3. Requirements Refinements : 이미 만들어놓은 것을 보니까, 만약 A라는 것을 해야 되는데 A'가 존재하면, B라는 것을 해도 되지 않을까 하고 고민할 수도 있음.
    (그것이 타당하다고 생각하면, 돌아가서 다시 Requirement Specification으로 돌아갈 수도 있고, 그대로 진행할 수도 있을 것이다.)
      >> ex1) 만들고자 하는 A에서 1~5번 기능을 만들어야 한다. 하지만 4번 5번은 나중에 만들어도 될 것 같으면, 해당 부분이 중요한 부분이 아니니 4~5번은 
              "이렇게 했으면 좋겠는데~" 하고 설득해 바꿀 수도 있을 것이다. (like, 원래는 Excel로 출력해야 했는데, PDF로 바꿀 수도 있는 것임)
  
  
  4. 실제로 어떻게 Reuse 할 것인가?
    4.1 Application system이 이미 있는 경우 >> 해당 System의 Configuration 만 바꾸고 그대로 써도 될 것이다. 
    4.2 Component만 되는 경우 : 
      4.2.1 일부 Component를 업그레이드 시켜서 사용한다. 
      4.2.2 일부 Component를 발전시켜 새로 만들겠다. 
    
    >> 이후 해당 System들을 모두 통합해 새로운 System으로 만드는 것도 가능하다. 
    
 -> 이 과정이 꼭 이렇게만 흘러가리라는 법은 없다! 다양한 갈래가 있을 수는 있음!
 -> 단순히 직관적으로 봤을 때 재사용을 한다는 관점에서 보면 이렇게 설명할 수 있다.
 -> 중요한것 ! : 왜 Reuse를 해야 하는가? + 어떻게 진행하면 되는가?
 -> 어떠한 방법으로 접근하느냐에 따라서, 이 갈래는 얼마든지 많아지고 줄어들 수 있다.
 -> 중요한 것은, "있는 것을 어떻게 활용하느냐?!" 임.
 
 
 -> Reuse하는 것의 장점 : Cost & Risk를 줄인다! + Delivery가 빠르다!
     
     >> Cost : 만드는 시간이 줄었으니, 비용이 줄었다고 생각할 수 있는 것이다. 
     
     >> Risk : 잘 개발된 소프트웨어를 가지고 오면, 자기 자신이 짠 것보다 리스크가 적다. 이미 남들이 많이 사용해보았을 것이고, 그만큼 Validation이 잘 되어 있다는
               의미이다. (물론, 실력 좋은 개발자 것을 들고 오고, 그만큼 구별하는 눈도 역시 있어야 할 것이다. ) 
               일단, 그러니 Reuse할 것들은 대체로, Validation 을 자기 자신이 한 것보다 훨씬 더 많이 되어 있는 것일 가능성이 클 것이다. 
               그러므로 Risk를 줄인 것임. 
               
    >> Delivery : 이미 누가 짠 것을 가지고 와서 Reuse하는 것이기 때문에, 빠른 개발 또한 가능하다!           
    
  -> Reuse 하는 것의 단점 : Requirement의 타협이 거의 무조건 생긴다. (+ 재사용한 system element에서는 evolution 이 안 될 수 있다. 자기가 짠 것이 아니므로)
    >> Customer와 이야기를 잘 해서, 잘 풀어나가야 되는 것이다. (협의를 해야 한다)
      (이런 부분에서 보면 Incremental 방법론이 좋은 부분이 있다. 만들다가 안되면 협의하고, 고객이 인정하면 타협이 되는 부분이 있음)
      (짜다가, 고객이 생각이 바뀌어서 다르게 생각할 수도 있으니, Reuse를 많이 해서 생산성을 높이자! 빨리빨리 잘 활용해서 만들자!)
      (실제로 짜놓은 코드가 전부 쓸모없어질 수도 있음)
      
      
 ** Process Activities :
  
  1. Requirement : Requirement를 추출한 다음, 그것에 대한 분석을 시행한다. 분석을 완료하게 되면, System Description이 나오게 된다. 
      >> System Description : 우리가 만들려고 시스템이 어떻게 생겼는지, 그 자체가 그려지는 것임.
        (ex: 어떤 내용이 실제로 작성되는가? 
         Description : 이 System은 누구를 위한 시스템이고, 사용하면 무엇이 좋은지 설명됨. 그래서 ~~~~를 하려고 한다!) 
         Requirement : 사용자가 ~~~한 기능을 수행할 수 있고, 시스템은 ~~~ 기능을 제공해야 한다. (설명서)) 
          (like : "시스템은 로그인/로그아웃을 지원해야 하며, 10분 이내로 로그인이 종료되어야 한다" 와 같은)
  
  
  1.1 Requirement Validation : Requirement 사이에서도 서로 안 맞는 내용이 나올 수 있다!
      >> ex) "고객은 한 장소에서만 로그인이 가능하다" with "한명의 사용자가 pc와 모바일에서 같은 주문을 확인할 수 있다"
            >>>> 모순임. 둘중 하나를 고치던치, 케이스별로 나눠서 하던지 해야 함. 
            >>>> 요런 것 검증을 꼭 해야 한다!
  
  
      >> 요런 것들을 막기 위해서 Requirement Validation 이 필요하다! Requirement 간에 충돌이 생겨버리면, 다른 하나는 못 구현하기 때문.
      >> 이 단계가 끝나면 완전한 Requirement Document가 나오게 된다. 
  
  
  2. Software Design & Implementation 
      >> 이에 앞서, 우리가 할 것들에 대한 어떤 여러 가지 Target들을 다 정의하게 된다. 
      >> Item 1,2,3 가 있다면, 각각의 Item을 어떤 식으로 구현할 것인가에 대한 의미가 Design이다.(구조를 어떻게 잡을 것인가?!)
      
      ex) 기존의 수강신청 + 수강꾸러미 기능 넣기
        >>>> 기존에는 수강신청 날 바로 수강신청을 했는데, 수강꾸러미 라는 제도가 들어가게 되면, 꾸러미 정원이 넘는지 안 넘어가는지도 체크해서 자동으로
             수꾸 안 터지는 것들은 수강신청이 되도록 해야 하며, 정원이 넘어가면 수강신청을 하게 만들어야 한다. 
      
      >> 이런 "수강꾸러미" 와 같은 기능이 하나 있고 없고에 따라 "수강 신청"에서의 전체적인 Mechanism이 바뀌게 된다!
          >>>> ex) 수강꾸러미로 수강신청이 된 과목인가 아닌가에 대해 비교하는 Logic 추가
                   정원이 넘친지 아닌지 확인하는 기능
                   넘치지 않은 과목에 대해서 자동으로 수강신청하게 해주는 Logic
                   
          >>>> 이렇게 되면 당연히 전체적인 설계가 달라질 수 밖에 없다. 
          
      2.1 Design Process에 있어서 일반적인 Model
        
        2.1.1 Design Output
        >> 결과물에 System Architecture, Database Specification, Interface Specification, Component Specification 있을 것이다. 
        -> 이런 것들을 보고 "System 설계서" or "Software 설계서" 라고 부름. 하나의 Architecture로 묶여져 있을 수 있다. 
        (물론, 저게 다 있어야 된다는 것은 아니다. 만약 DB가 들어가지 않는다면 DB가 없을 것임)
        (System Architecture 정도는 있어 줘야 함. 그래야 전체적인 시스템을 이해하는 데 이해가 될 것이다.)
        (Component Spec 정도는 보통 있어야 하고, Interface Spec 까지 Design에 있으면 좀 상세하게 적은 것이라 할 수 있다)
        (Component Spec -> 들어가는 여러가지 Component들이 어떤 것들이 있고, 어떤 역할을 한다는 것 정도 있어 줘야 세부 구현이 가능)
        (Interface Spec 있으면 Component간의 관계에 있어 어떻게 상호작용하는지 알게 되니까 더 좋다)
        
        2.1.2 Design Input 
        >> Requirement Spec : 앞에서 했던 설계. 제일 중요하다. 
        >> Data Discription : 어떤 데이터가 어떤 데이터 타입을 갖고있는지? 중요하다. 
        ex) 숫자가 입력이 문자로 들어오고 있으면, 이런것들 처리하는데도 뒤에 것들을 다 바꿔야 하니 일손이 많이 들어갈 것이다. 미리 정하고
        들어가면 제일 좋다. 
        >> Platform Information : 도데체 "어디서" 동작하는가? (PC에서 돌아가느냐, 안드로이드에서 동작하는가?) 
        -> 이것에 따라서 설계가 완전히 달라지기도 한다. 
        
        2.1.3 Design Activities : 
        >> Architecture : 어떤 큰 틀로 만들어질 것이냐? 
        >> Interface Design : 어떤 입력방식으로 동작하냐? 어디서 출력하냐?
        >> Component Design : 위에서 한 것들을 가지고 세세한 Component들을 만들고, 디자인함. (크게 Class 설계라고 보면 된다)
        >> DB Design : 마지막에 DB를 디자인한다. 다 나온 뒤에 DB를 설계하면 어떤 애들을 어떤 부분에 넣을지 1대 1로 설계가 가능하다. 
              (원래 앞의 내용들은, DB를 어떻게 사용할지 염두에 두고 앞의 내용들을 먼저 설계하는 것이 좋다)
        ex) 카카오톡 : 
            - 인트로 있을 것임.(바뀌기도 하고, 이벤트들도 있을 수 있다)
            - 메인 레이아웃(친구창, 채팅창, 더보기, 설정)
            - 조금 더 디테일한 사항들(이 항목들은 어떤 일을 합니다!) // Architecture
            
            - Interface : 카톡은 휴대전화에서 터치로 동작한다. (누르고 있을 때, 눌렀을 때 다 다름, 꾹 누르면 삭제, 관리 등이 나옴.) -> 요런 사항들 관리
            - Interface Design(상세) : Component 사이에서의 전환이 이루어지면 어떻게 효과를 줄 것인가? 어떤 명령을 내리면 어떻게 넘어가나?
            (인터페이스 디자인은 높은 추상화 레벨에서 돌아가는 것이다. 코드에서의 인터페이스 단계는 아니지만, 거기까지 가도 문제는 없다)
            
            (최대한 상위 레벨에서 점점 깊게 들어가는 단계이다) (Top-down으로 내려갔다, Bottom-up으로 올라오는 것임)
            
            - Component Design : 위에서 했던 것들을 가지고 세세한 Component(Class)를 만들고, 디자인. 
            
            (하면서 세부 인터페이스를 설계하고, 인터페이스를 구현하기 위한 Class도 필요할 수 있을 것이다. 해당되는 애들을 설계)
            
        >> 꼭 이렇게 정형화 되어야 하는 것은 아니다! (DB가 없으면 빠져야 할 것임)(일반적인 <가이드라인>은 이렇다!)
        >> 하지만, 절차대로 설계하는 것이 제일 좋다! 먼저 System Requirement를, 최대한 문서 안에 있는 애들을 다 뽑아내면서 다 잡아내고
          그다음에 Architecture, Interface Design, Component Design, DB Design 식으로 잡아주면, 문제없이 효율적으로 할 수 있을 것임. 
          (+ 있어야 할 애들이 없으면, 다음 단계로 진행이 불가능할 수밖에 없다. Requirement Spec, Data Discription, Platform Information
          중 하나라도 없으면, 만들수 있는 것이 대단히 제한적일 수 밖에 없다)
      
  3. Programming(구현) >> 그냥 일반적으로 하듯이, 위에 것들을 다 잡고 구현을 하면 된다. 본인 스타일대로 하는것이 제일 효율이 좋다. 
        
  4. Software Verification & Validation  : 
    4.1. Verification  
      >>앞서 나왔던 스펙들과, 만들어 놓은 프로그램의 스펙을 1:1로 비교하는 것이다. 
    
    4.2. Validation 
      >> User Requirement와 맞는지 비교하는 것임. 스펙과 1:1로 매칭되는 것이 아니다. Spec상의 Requirement 여러 개가 User의 요구사항 1개일 수 있다. 
      >> 반대로 User의 요구사항 여러 개가 Requirement 하나로 귀결되어 정해질 수도 있는 것임. 
      >> 쨋든 잘 맞는지 Requirement와 비교하는 것이다. 
      
   5. Testing     
    -> Component Testing, System Testing, Customer Testing이 있다. 물론 이 전단계의 테스팅도 있지만, 그것들은 개발단계에서의 Testing
       이기 때문에 여기에는 포함하지 않는 것으로 한다. 틈틈히 테스팅해보면서, 안맞으면 다시 그 위의 단계들부터 왔다갔다 해야 하기 때문. 
    
    5.1 Component Testing :
      >> 각 클래스들을 서로 유기적으로 연결해 보아 테스팅하는 것. 이 클래스 저클래스 다 불러서 호출해보면서, 테스팅하는 단계
      (일반적으로 하나의 Component = 하나의 Class!)(클래스 내의 메소드들을 다 부르면서 테스팅하는 단계이다)(Class 간의 interaction도
      확인 해야함!)
      
    5.2 System Testing :  
      >> 여기서부터는, 흔히 말하는 "Spec Based Testing"을 한다. Compound끼리 다 연결해서 테스팅해 보았으면, 하나의 시스템이 된 것이다,
      >> 하나의 시스템을 전체적으로 테스팅하는데, 시스템을 만든 이유인 "스펙"과 비교하면서 테스팅하는 것이다.
      >> 이것을 만족하면 System 테스팅이 되었다고 말할 수 있는 것이다. 
      
    5.3 Customer Testing(known as Acceptance Testing or User Testing ) 
      >> 유저한테 직접 보여주면서 확인받는 것. 유저가 Accept하면 오케이임. 
        ex) 스펙에서, "100시간 동안 시스템이 죽어서는 안된다!" 라고 한 소프트웨어를 테스팅받는데, 95시간 째 죽은 것을 확인함. 
            (그 전 테스팅할때는 안그랬는데 >> 데모의 저주)
            근데 유저가, 50시간쯤이면 되었는데 빡빡하게 100시간 찍었다! 이정도면 오케이다~ 라고 한다면, 그냥 출시하면 되는 것이다.
            근데, 다른 것도 다 안되면, 당연히 여기서 오케이 받을 수는 없을 것임. 
           -> 이래도 고객이 "받아들일 수 있는 수준" 이면, 오케이 된다~(유저가 본래 원했던 스펙 수준보다, 출시되는 것들이 대부분 약간씩 낮다)
          
      >> Customer가 그냥 앉아서 한번 써 보는 것도 Customer Testing이다. Customer가 옆에 앉아서 이렇게 해주세요, 저렇게 해주세요 하는 것도 
        Customer Testing이라고 부를 수 있는 것임. 
        
      >> Customer Testing, Acceptance Testing, User Testing 다 비슷한 범주에 있긴 함. 하지만 용어에 따라 조금씩 뜻이 다를 수 있다. 
      >> 마지막인 이 테스팅은, 범위, 범주가 넓기 때문에 사실 모호한 개념이긴 하다. 
      
      
      *** V Model (그림 2.3)
      Business Requirement Specification (계획 전 단계)(뭐 때문에 필요해!) -> 보통 Business Requirement와 System Requirement 합쳐부름.
      System Requirement Specification -> Requirement Specification (여기서부터 우리가 아는 계획!)       ->> 계획, 디자인, V모델 왼쪽
      High-Level Design -> System Design(& Implementation)(디자인하는 단계)

      Low-level Design, Coding, Unit testing -> 구현(Low-level Design도 그런것인지는 확인해야 함!)->(모호하다. 누가 하냐에 따라 다르다)    

      Component Testing (프로젝트의 규모에 따라 패키지 단위로 Component를 나누기도 하고, 작은 프로젝트라면 클래스 단위로 나누기도 함)
      System Integration Testing (System Testing 과 Integration Testing을 나눠서 하는 경우도 있음. 하지만 거의 뭉쳐서 함) ->> Testing
      Acceptance Testing 


      >> 요런 단계와 순서가 있기 때문에, 보통 이런 순서로 개발이 된다 라는 것 정도 인지하면 된다!
      
      
    6. Software Evolution
      >> 모든 개발이 끝나고 나서 사용하다보니, 조금 더 개선해야 할 부분이 있거나, 필요했던 기능들이 더이상 필요하지 않고 다른 기능이 필요하는 등
         뭔가를 더 넣어주고 수정해줘야 할 때 진행하게 된다 (Change가 필요할 때, 기능상의 추가삭제, 시스템 자체의 변화
         사용자의 변화, 사용환경의 변화 등등을 모두 Change가 필요할 때라고 부름.)
          ex) 소프트웨어가 변한 것은 없는데, 사용자가 바뀐 경우. 
          (20대가 쓰는 것과 노인분들이 쓰는 것은 달라야 할 부분이 있다. 노안이 오신 분들은 글자가 작거나 너무 화려하면 보기 힘듬)
            -> 기능상의 변화는 없지만, 조금 더 글씨를 키운다던지, 조금 더 보기좋은 색감 등등이 있어야 한다. 이런것들도 일종의 Change!
           
      >> Requirement Change도 있고, 다른 Change도 있다. 이럴 때 Maintainance가 필요하다!
            
            
       6.1 Evolution의 단계
                  ---------------------------------------------------------------------------------------          
                  |                                                                                      ^
        Define System Requirements ---> Assess Existing Systems ---> Propose System Changes --> Modify Systems
                                                ^           ^                                           |
                                                |           |                                           |
                                       Existing Systems     ---------------------------------------  New System  
                                       
           
           *** 요구사항이 있으면 요구(Define System Requirement)
               현재 해당 시스템이 있는지 확인(Assess Existing Systems)
               시스템 변화 관찰&제안(Propose System Changes)
               (변화 찾은 후) 어떤 부분을 고쳐야 하는지(Moddify Changes) 
                  -> 찾은 뒤 Define System Requirement로 돌아갈 수도 있고, 완전히 새로운 시스템(New System)이 될 수도 있음.
                  
                 
              New System이 된 뒤에도, 해당 시스템에 대해서 다시 평가를 하게 되고, 다시 Cycie을 돌면서 진행하게 된다. 
              (앞에서 했던 개발 방법론과 비슷하지만, Evolution에서는 Requirement Spec이라던지 그런 부분은 빠지게 된다)
              (물론 "New System"이 되는 경우, 그 단계 안에서는 다시 Requirement Spec이라던지 하는 부분이 들어가게 된다)
              
           *** Evolution의 경우, 평가하는 부분(Assess Existing System)이 있는데, 단순히 Validation만 하는 것이 아니라,
                그 외 Performance 같은 것들, 그런 다른 것들도 모두 평가를 하게 된다. (평가라기보다는 파악에 가깝다)
                
           >>> 저 사이클이 계속 반복하게 된다! 유지보수하는 내내!   
            
         
  ** Coping with Change( Change가 발생했을 때, 어떻게 처리하느냐에 따라 처리속도, 개발 결과물이 완전히 달라진다!)
  
    >> 팀프로젝트를 하면 반드시 수정이 일어나게 된다! (여러가지 이유가 있음. 개발자가 잘하고 잘못하고, 과제가 바뀌고, 내가 이해를 못하고 등등)
    >> 규모가 크면 클수록 반드시 Change가 일어날 수 밖에 없다! Business 내에서의 내용이 바뀌면 Requirement부터 시작해서 다 바뀜. 
    >> 신기술이 나타나도, 그것을 사용자가 요구하기 때문에 개선할 수밖에 없음
    >> 플랫폼(PC -> 스마트폰)이 바뀌어도 그에따른 변화가 나타날수밖에 없다. 
    
    -> 결국에는 Change가 rework를 발생시킴(다시 일해야 된다는 뜻, 비용도 그에 맞게 발생함)
    -> Requirement를 다시 분석해야 하는 이유가 된다. (Re-design, Re-implementation 포함)
    
    
    -> Rework하는 비용을 최대한 줄여야 한다!
      >> 구현하는 비용과 Testing 비용으로 나뉘었을 때, Testing하는 비용이 생각보다 많이 든다. Testing에서 문제가 발생하면, 
         다시 구현해야 하는 비용이 계속 발생하기 때문. Change로 인한 비용발생도 여기에 포함된다.
      >> 중요한 Rework가 발생하고, 그에 맞게 다 시스템이 새롭게 바뀌어야 한다!
      >> 그런 것들을 다 감안하고, 프로그래밍 할 때 마다, 수정사항이 생길 것을 염두에 두고 개발하는 것이 좋다!
      (어느정도는 내부 세부사항이 바뀔 수 있다 라는 것을 염두에 두고 작업을 해야 한다.)
      
      >> Change가 발생했을 때 어느 정도까지 감내할 수 있는가? (어느정도까지 대비 가능한가) & 어느 정도까지 대비할 수 있는가?
        2가지가 중요하다!
        
        
      *** About Prototyping
          >> 변화에 쉽게 대응할 수 있는 방법 한가지!
          >> 프로토타이핑이란, 당연히 프로토타입(원형, 뼈대, 프로그램의 큰 줄기, 개략적인 큰그림)을 만들어 보는 것
          >> 처음부터 디테일하게 만드는 것이 아니라, 뼈대만 간단하게 만들어 보고 나서, 고객에게 이 정도면 맞느냐고 물어볼 수 있는 
             Product. 고객은 만들어진 Prototype을 보고 나서, Requirement, Feasibiility(구현 가능한가?)를 확인할 수 있는 것이다. 
             실제로 만들어진 Prototype을 보고 나서, Customer의 Feedback을 받을 수 있을 것이다. 이것을 가지고 설계할 때 해당 Change를
             거기에다가 집어넣을 수 있는 것임.
          
          >>  바뀔 것을 생각하지 않고 만들면, 그냥 쭉 만들면 된다. 하지만, Prototype을 만든다는 것은 Change가 있을 수 있다는 것을
              염두에 두고 만드는 것이다. 그러니 프로토타입을 만들고 고객에게 다시 한번 확인하는 것을 거치는 것임. 
              
          >>  Incremental Delivery하는 이유는, "Change를 피하고 어느 정도 감내하기 위해서" 임. 
              개발하기 전에는, 고객이 어떤 것을 바꿔야 할 것 같다고 말했지만, 막상 1차 나오고 나면, 고객이 마음이 바뀌어서 안 해도 될 것
              같다고 다시 의견을 낼수도 있을 것임. 있을지도 모르는 Change가 사라졌다. 
              + 최종장에 발생할 Change 를 중간에 한번 확인해 봄으로써 나중에서의 Change를 없애는 것임. 
              + 그리고 이때의 중간결과를 가지고 Customer와 이야기해 봄으로써 Customer를 설득할 수도 있음.    
            
         
          >> Prototype을 Initial Version이라고도 함. 2번째 3번째도 Initial Version이라고 할 수도 있긴 함. (프로토타입 만들고 나서 고객이
              맘에 안들어할 경우, 새로운 프로토타입을 계속해서 만들어서 고객을 만족시킬 수 있는 것임. System의 정확한 Concept이 정해져 
              있지 않을 때 1,2,3번째 이렇게 만드는 것을 보고 Prototype이라고 많이 이야기한다. )
              
           >> 본 개발에 들어가기 전에 개발자가 개략적으로 만들어서 보여주는 것은 모두 다 Prototype이라고 이야기할 수 있다. 
           >> Customer 에게 보여줌으로써, Concept를 확정하는 데 쓰이는 것이 Prototype이라고 할 수 있겠다.  
           >> 1차적으로 Requirement 을 고객에게서 끌어 내고 Validation하는데 쓰이기도 한다.
              (구체적으로 이게 맞는지 틀렸는지 따지기보다는, Prototype을 보여줌으로서 시각적으로 보여주기도 함. UI design도 포함된다
              결국에 눈으로 보는 것들은 UI이다! 아무리 시스템을 잘 짜놔도, 눈에 안보이면 제대로 설명하기 어렵다! 그래서 UI가 들어가야 함)
              
           >> 테스팅 프로세스에서도 Back-to-Back 테스트용으로도 가능하다. 실제로 지금 만든 Prototype을 본 개발까지 가져갈 수도 있다. 
               Customer가 이렇게 해도 될 것 같다고 한 것을, 그대로 가져가도 될 것 같으면, 최종 마지막 Test때, Prototype에 들어간 UI가
               사용이 가능하다.
           
        *** Benefits of Prototyping
          1. 시스템의 사용성 (Usability, 사용자가 쓰기 편한 정도) 향상
            >> 시스템을 요구사항대로 만들다 보면, 개발자 편하게 만드는 경우가 많다. 처음부터 Prototype을 만들다 보면, User가 그것을
                계속 그것을 보게 될 것임. Feedback을 처음부터 해 주게 되고, Usability(사용자가 쓰기 편한 정도) 가 자동으로 올라가게 됨.
                
          2. User의 실제 Need에 가까워지게 된다. 
            >> 처음 고객이 개발자에게 설명할 때, 굉장히 추상적으로 말할 수 밖에 없다.(고객도 "정확히" 어떤 것을 원하는지 본인도 모름)
            >> 설명한 기능들은 다 알겠지만, 그 외적인 기능들은 개발자가 상상해서 뽑아내야 함. 
            >> Prototype을 만들어서 갖다 주면, 그것을 보고 User가 좋다/나쁘다/원했던 게 이게 아니다 등 자세하게 이야기해 줄 것이다. 
                그렇기에, Closer Match(원하는 것에 더 가깝게 ) 된다.
                
          3. Design Quality 가 더 좋아진다
             >> 이미 한번 만들어 봤기 때문에 뼈대가 정해진 상태로 가는 것임. 
             >> 앞서 나왔던 Change가 많이 해소가 된다. 
             
          4. 결론적으로 개발 비용이 많이 줄게 된다!!    
          
         *** Prototype 개발하는 Process
         
          1. Establish Prototype Objectives : 처음에 어떤 프로토타입을 만들지 정함
          
          2. Define Prototype Functionality : 어떤 "기능"을 프로토타입으로 정할지 정함. (UI보다 기능! 기능이 훨씬 중요하다. UI도 프로토타입으로
                                              넣어서 하는 이유는, UI가 있어야 고객에게 시각적으로 바로 보여줄 수 있기 때문. 그래야 고객이 보고 
                                              정확한 피드백을 해준다. 
                                              
          3. Develop Prototype : 실행 가능한 프로토타입을 만든다. 
          
          4. Evaluate Prototype : 프로토타입을 고객과 함께 평가받고, 그것으로 고객에게 완전한 Requirement를 뽑아낸다!
          
        *** Prototyle 개발
          >> 빠르게 만들어야 한다. 전용 언어나 툴로 개발한다. 빠르게 만들어서 고객에게 평가받는 것임. 
          >> 당장 나오는 에러는 싹무시한다. 어차피 본 개발이 아니기 때문에 Error Checking, Recovery 싹 무시하고 일단 피드백 받으러 만드ㄹ는
             것이기 때문
          >> 프로토타입은, 주로 "그냥 말로 했을 때 잘 이해되지 않는" 애들을 "개발자" 가 이해하기 위해서 만든다. 그리고 그런 것을 확실히 
             하기 위해서 만든다. 일단 굵직한 "줄기" 들을 이해해서, 그것을 바탕으로 프로토타입을 만들고 고객에게 들고가서 추가적으로 완벽히
             이해하는 것을 중점으로 한다  
          >> Reliability & Security같은 Non-Functional requirement 들도 Prototype 만들 때는 개나준다는 마인드. 본 개발이 아니기 때문.
          
        
        *** Throw-Away Prototypes 
          >> 프로토타입을 만들고 나면, 그것을 토대로 계속 만들어나가는 방법론도 존재한다. 하지만, 얘들은 위에서 말한대로 그냥 고객에게 
             확실한 Requirement를 얻기 위해서 빠르게, 어찌보면 대충 만들었던 것이다. 
          >> 그렇기에 이러한 프로토타입 시스템을 개조해서 non-functional requirement까지 다 만족시킨다는 것이 정말 쉽지 않다. 
          >> 거기다가 프로토타입들은 일반적으로 관련문서를 하나도 안써놨다
          >> 그렇기 때문에, 프로토타입들은 단순히 고객에게 완전한 Requirement를 얻어내고, 개발자가 고객의 Need를 이해하는 용으로 쓰이기만
             하고, 대부분의 개발자들은 해당 프로토타입을 그냥 개발에 이용하지 않고, 밑바닥에서부터 새로 시작하는 경우가 많다 
             
             
        *** Incremental Delivery :
          >> 그냥 단순히 Delivery 하는것보다는, 나눠서 단계적으로 Delivery 한다. 
          >> 각 Delivery마다 중요한 기능 하나씩 있다! (A 버전 낼때는 기능 1, B버전 낼때는 기능 2, C버전 낼때는 기능 3 이런식)
          >> User Requirement에서 우선순위를 정해 놓고 중요한 순서대로 먼저 Delivery한다. 
            (중요한것부터 먼저 개발하는 것이 좋다. 중요한것들이 먼저 만족되고 나면, 다른 세부적인 것들은 조금 다르더라도
            감내할 수 있는 것임)(Incremental Delivery할때는 Highest Priority 부터!!)
            
          >> 다음 Incremental Delivery 할때는, 그전 Delivery보다 더 나아진 Version으로 나와야 한다~
          
          
        *** Incremental Development & Delivery (점진적 개발과 점진적 배포!)
          >> Develop하는 것은 단계별로 진행을 하되, 각 단계마다 그에 해당하는 "Evaluate"(평가) 가 있어야 한다!! (Set로 가는것임!)
          >> Running Version이 하나가 나오면, 그 Running Version에서의 Evaluate(평가)가 하나씩 뒤따라야 한다! 
              (Evaluate > Test, 일맥상통하지만, Evaluate가 더 큰 범주. Testing 뿐만 아니라 그 외적인 부분들도 평가하는것임.)
          >> 반드시 단계별로 개발되면, 단계별로 평가!!
          
          >> Agile Method에 많이 사용되는 방법 중 하나. 평가는 반드시 고객이 하는 것이다! 개발자가 단순히 평가하고 끝내는것이 아님. 사용자나
              고객이 하는 것이다
          >> 단계별 배포는, 최종 사용자(end-usre)에게 배포하는 것이다!  (개발자도 User 중 한명임. 그러니까 End-user에게까지 배포하는 것이다)
          >> 개발자가 Test하는 것을 Alpha-Test / 유저가 Test하는 것은 Beta-Test(그 게임에서의 베타테스트 맞다. 당연히 베타테스터는 End-User이지.)
          >> End-User가 해야되는 이유는, 실제 Running Version을 배포한다는 것이, 이미 바깥에 "출시하는" 프로그램이라는 의미이다. 당연히 조금 더 
             실제 사용하는 것과 동일하게 해야 한다는 것이다! 조금 더 Realistic해야 하는 이유임. (그렇기에, 점진적 배포가 중요하다)
          >> 베타테스트를 계속 하면서 테스트해 보고, 마지막에 stable version(정식 버전) 이 나오게 된다. 
          
          >> 개발자들은, 해당 프로그램을 개발할 때 개발툴을 다 가지고 개발을 해서 완성을 하지만, 유저들은 그런거 없이 해당 파일만 깔아서 실행을 시킨다.
             이때, 유저 입장에서는 실행이 안 될 수도 있다. 그렇기에 개발자들은 개발킷이 없어도 유저가 프로그램을 실행시킬 것을 염두에 두고 개발을 진행해야 함. 
          >> 배포할 때도, 필요한 부분들을 같이 배포하는 것이다!
          
          
       *** Incremental Delivery (그림 2.4)
              
              1. Define Outline Requirement : Requirement 큰 뼈대 식으로 정해두기 & 우선순위 정하기
              2. Assign Requirements to Increments : 큰 뼈대 차원에서 정한 Requirement를 몇개로 나눌 것인지, 몇번 단계에 어떤 Requirement를
                                                     배치할 것인지 정함. 
           
              3. Design System Architecture : 1~2번에서 정한대로 System Architecture를 Design
              4. Develop System Increment : (4~8번 반복. 1~3번까지는 "어떻게 점진적으로 개발하겠다!"가 나오는 단계임)
                                            (Design / Implementation / Evaluation이 해당 4~8번으로 계속 반복되는 것임.)
                                              정한 것들 중 일부를 구현하는 단계
                                              
              5. Validate Increment : 만든 것을 확인해보는 단계
              6. Integrate Increments : 만든 것을 통합시키는 단계( Version 1, Version 2 등 단계를 만들어놓은 것을 합친다)
              7. Validate System : 합친 뒤에 System Validate를 한번 더 함. (그 전 것은, 만든 것만 Evaluate하는 단계였다면, System을
                                    Validate하는 것은, 합친 전체의 System을 통합해서 Evaluate해보는 것임.)
                                    
                                    
              8. Deploy Increments : 배포하는 단계. 배포하고 나서, 모자란 것이 있으면 다시 4단계(Develop System Increment)단계로 가서 개발함. 
              
              
       ***  Incremental Delivery의 장단점
       
         - 장점
         
          >> Customer가 직접 Delivery된 것을 받아볼 때, 각각의 단계가 바뀔때 마다 받아볼 수 있음. 실제 Functionality 가 잘 동작하는 지 빠르게 확인할 수 
             있다. 시스템이 다 개발될때까지 받아보면, Incremental Delivery하는것보다 훨씬 느리다. 그리고 고객이 확인할때, 개발자는 또 다른 개발을 진행하고
             있을 수 있다. 시간적으로 많이 Save된다.
             
          >> 초기 Increment들은 Prototype처럼 활용할 수 있다는 장점이 있다. Requirement를 확실하게 확인할 수 있으며, 다음 개발 때 반영할 수 있다. 
          
          >> Risk가 적다! 단계적으로 진행할 때 마다 잘못된 것이 있거나 달라진 것이 있으면 그때그때 이야기하면서 상호작용이 가능함. 프로젝트가 실패할 가능성이 
              그만큼 낮아진다!
              
          >> 높은 우선순위를 먼저 진행함으로써, 그 다음 단계들로 나아갈 때 마다 메인 우선순위를 차지하는 기능은 그만큼 더 많은 Testing을 하게 된다. 
             Highest Priority의 testing 횟수가 다른 Priority의 기능들보다 더 많아지면서, 가장 높은 우선순위의 기능들은 에러가 날 확률이 더 낮아진다. 
             관리에 용이하다.(Highest Priority의)
             
         
        - 단점 (점진적 개발의 문제점)
        
           >>  중요한 파트가 다른 시스템에 종속되어 있을때(우리 시스템이 아닌 다른 시스템에 있는 파트)(like 결제 시스템 in 쇼핑몰), 해당 파트를 검사하기가
               대단히 까다롭다. 이런 경우 나중에 확인해야 한다. 이런 부분에 있어서만큼은, Priority가 대단히 높지만, 바로 진행하기가 까다롭다. 
               자기가 만든 게 아닌, 기존에 있던것을 쓰는 경우 -> Incremental Delivery가 문제가 될 수 있다. (System 자체가 다르기 때문에 갖고오는 것이 불가능)
           
           >>  반복하는 프로세스가 반드시 들어가게 된다. 다른 소프트웨어와 결합하는, 가져와야 하는 Spec이 있는 경우 
                ex) Java로 개발하고 있는데, C로 짜여진 다른 소프트웨어와 결합해야 하는 경우, API를 받아오거나 해당 소프트웨어를 뜯어서 해당 부분을 다른 언어로
                    새로 개발하거나 하는 경우. (합치는 모델들을 사용해서 충돌된 요소들을 해결해줘야 함.) 
                -> Incremental Delivery / Development 로 하는 경우, 여러 번 나누어 할 때, 그런 것들을 합쳐야 할 때의 이슈들을 다 파악해서 진행하는 것이 좋다. 
                
 ** Process Improvement
    >> 
                
    
