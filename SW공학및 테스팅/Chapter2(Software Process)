< 2장 : Software Processes >

* Topics Covered
- Software Process Model
- Process 활동(Activities)
- 변화가 생겼을 때 Changing
- Process Improvement


** Software Process(개발 프로세스)
  -> 소프트웨어 개발 시 필요한, 정형화된 활동
    >> 건물 짓는 것에 많이 비유한다. 단순히 "아파트를 짓는다" 는것이 아닌, "방은 몇 개인지 등등"을 정하고 나서 건축을 하는 느낌이다. 
  
  -> Specification : 
    >> 위에서 말한 소프트웨어의 "스펙"을 정하는 것. 가급적 상세하게!
  
  -> Development(Design and Implementation) : 
    >> 위에서 말한 해당 스펙을 가지고, 세세한 "디자인" 을 먼저 진행한다! (디자인 설계 단계)
    >> 위에서 말한 디자인 단계가 전부 이루어지고 나면, 그제서야 Implementation(구현)을 하는 것이다. ( 설계대로! )
     
  -> Validation : (소비자가 원하는 모습과 일치하는지! (1장에서 상세히 정리)(복붙하기))
  
  -> Evolution : (상황, 정보의 변화에 맞게 새로 evolution!  (1장에서 상세히 정리)(복붙하기))
  
   -> 스펙이 상세할수록 디자인하기 쉽고, 디자인이 상세할수록 구현하기는 쉽다. 하지만, 상세하지 않다고 해서 디자인이 안 되거나 
      구현이 안 되는 것은 아니다! 
      
** Plan-driven and Agile Process
  -> 개발을 할 때 크게 두 가지 방법으로 나눌 수 있다! ( Plan-Driven vs Agile )
  -> Plan-Driven : 
    >> 말 그대로 계획이 모두 정해져 있는 것.
    >> 만약 처음에 1년 동안 개발한다고 정해 두었다면, 1년치 계획을 다 짜는 것이다. 그리고 수행하는 것.
    >> 뭔가 다 정해져서, 바뀔 일이 없을 때 해당 방법을 사용하는 것이 유리하다. 
    >> ex) 방산 프로젝트 / 한번 만들어 본 것을 다시 만들 때(이미 어떻게 흘러가는지 계획이 다 있는 경우)
    
  -> Agile : 
    >> 딱히 엄청 커다란 계획같은 것은 없다. 단지 계획은 그냥 Incremental(점진적으로) 하는 것.
    >> 개발하다 보면 뭔가 또 바뀌는 사항 같은 것들이 있을 것이다!
    >> 바뀌면 그에 맞춰서 또다시 계획을 짜고 개발하는 것을 무한 반복하는 것이다.
    >> 이러다가 또 고객의 요구사항에 따라 계속 반복하는 것임.
    >> 요구사항이나, 상황이 분명히 바뀔 것 같을 때 사용하는 것이 유리한 개발 방법이다. (해당 변경건으로 인해 계획 내용이 바뀔 것이기 때문)
    >> 나쁘게 말한다면, 그냥 마구잡이로 개발하는 것. 일단 고객이 있으니, 어떻게든 개발해보고 고객에게 보여주고, 아니라고 하면 그에 맞춰서 
       또 개발하는 것이다. 
    >> ex) Plan-driven 의 사례가 아닌 대부분의 사례
       
  -> (실제로는, 실제적인 개발 프로세스에는 두 가지 개발 방법의 요소가 둘 다 섞여 있는 경우가 많다. 두가지 방법 다 맞는, 혹은 틀린 방법은 
      아니다. 상황에 따라 두가지 방법 중 더 잘 맞는 방법을 선택하는 것이다.)
      
 ** 개발 프로세스 모델
 
  -> Waterfall model : 
    >> Plan-Driven 개발방법의 대표적인 사례. 폭포수가 아래로만 쭉 떨어지듯이, 거꾸로 올라가지 않고 한 방향으로 쭉 진행하는 모델
    >> Specification / Development / Validation 단계별로, 한 단계를 지났으면 그 단계로 다시 올라가지 않는다. 
      (Specifiation이 끝나고 Development 단계로 왔으면, 다시 Specification 단계로 되돌아가지 않는다!)
    >> 완전히 단계가 딱 나누어져 있는 개발 프로세스 모델! 각 단계가 나누어져서 구별이 된다~
    
  -> Incremental Development(점진적, 단계적 개발)
    >> Specificatoin / Development / Validation이 한 템포에 같이 진행된다. 
    >> 1번기능, 2번기능 3번기능 이 있으면, 1번 기능만 만들고 출시하고, 이후 2,3번은 나중에 개발해서 업데이트 하는 식이라,
       Plan-Driven이라고도 할 수 있고, Agile이라고도 할 수 있다. 1번 기능 출시할 때는 Waterfall model 처럼 구현했을 것이다.
       그러면 그 상황안에서만 Plan-Driven처럼 개발한 것이다. 하지만, 1번만 개발하기 위한 걔획만 짰으니 Agile이라고도 할 수 있는
       것이다. 이후 2,3번도 개발해야 하기 때문이다. 
    >> 어떤 측면에서 보는지에 따라 Plan-Driven이라고도 할 수 있고, Agile이라고도 할 수 있다. 
    
  -> Integration & Configuration  
    >> 결국 일부를 만들어 놓고, "통합" 하는 것이기 때문에, 일부를 만들때는 Plan-Driven / 전체로 볼때는 Agile 이라고 할 수 있다.
    >> 입맛에 맞는 대로 부르는 느낌인 것이다. 
    >> Configuration(환경 설정) 하는 부분도 마찬가지이다. 
       
  -> ( 결국 큰 프로젝트에서는, 해당 모델들을 조화롭게 사용해서 개발하게 될 것이다 )
  
** WaterFall Model : 

  -> Requirements & Definition----- 
            ^                      |
            |                      |
            |                      |
            |        System & Software Design---------
            |                      ^                 |
            |                      |                 |
            |                      |                 |
            |                      |                 |
            |                      |       Implementation & Unit Testing ----------
            |                      |                 ^                            |  
            |                      |                 |                            |
            |                      |                 |                            |
            |                      |                 |                            |    
            |                      |                 |                  Integration & System Testing---
            |                      |                 |                            ^                   |                                                                      
            |                      |                 |                            |                   |
            |                      |                 |                            |                   |
            |                      |                 |                            |                   |
            ------------------------------------------------------------------------------  Operation & Maintenance
                                                                    
                                                                    
    >> Requirement : Requirement Analysis라고도 많이 이야기함. (요구사항 분석). 실제로 고객이 어떤 소프트웨어를 원하는지
                     요구사항을 분석해야 한다는 것임. 요구사항을 분석해서 나오는 결과가 "스펙"이다.
                     이 단계에 오게 되면 Requirement Define 역시 되는 것이다. Specification Document(설계서) 역시 여기서
                     나오게 될 것이다. 
                     
    >> System & Software Design : 위의 결과물, 스펙을 보고 어떻게 디자인되어야 하는지가 나올 것이다. 그 과정을 수행한다. 
                                  이 단계에서 역시 Software Design Document가 나온다. 다 문서화해서 나옴. 
    
    >> Implementation & Unit Testing : 구현하고, Unit 테스팅하는 것.  구현할 때 보통 Unit(단위) Testing을 같이 수행하게 된다. 
                                       대체로 여기서 말하는 Unit이란, Java의 Class 단위를 말한다. 최소한 클래스 단위에서는 테스팅이 
                                       해당 단계에서 끝나야 된다는 것이다. 그렇다면 그 클래스 하나만 쓸 때는, 해당 클래스가 이상이 있는지
                                       없는지 파악할 수 있을 것이다. C에서 Unit이란, Function 단위를 말하는 것이 될 것이다. 
    
    >> Integration & System Testing : 이 단계가 본격적인 테스팅 단계이다. Unit을 같이 유기적으로 써 보면서, 이렇게 유기적으로 사용했을 때 
                                      문제가 되는지 안되는지를 확인하는 것이 Integration & System Testing이라고 보면 될 것이다. 
                    
    >> Operation & Maintenance : 시운전 해 보는 것이다. 이후 유지보수 함. 이 유지보수에도 3가지 종류가 있다! (기능상의 추가 / 수정 / 삭제 )
         
         
 -> 상세 설명 :         
    >> 맨 처음 요구사항에서 안맞으면, 요구 사항으로 다시 이동할 수도 있다. 만약에 설계(Design)이 잘못 되었다면, 설계도 고치러 다시 올라갈 수 있다.
       구현상 어떤 problem이 있다면 구현 단계로 다시 올라간다.  WaterFall 모델에서는, 어디 단계에 있든 끝까지 가야 한다. 그런 다음 다시 내려가는 
       것이다. 
    
    >> 이 단계 자체는 다른 방법론에서도 똑같이 등장한다. 하지만, 다른 방법론과는 다르게 WaterFall Model에서는 이 단계를 명확히 구분해서 개발하는 반면에
       다른 방법론에서는 단계의 경계가 모호하다. 다른 방법론에서는 스펙을 정의하면서 설계할 수도 있고, 설계하면서 구현할 수도 있는 것이다. 
       하지만, WaterFall Model(Plan-Driven 방식)에서는 다 구분해서 진행을 한다.  
                                 
    >> 요구사항, 설계, 구현상의 변화가 일어나게 되면 대응하기 상당히 어렵다. 끝까지 돌려보고 나서 그 다음에 올라오기 때문에, 요구사항이 바뀌면 그 아래도
       쭉 따라 바뀌기 때문이다. 그래서 이런 변화가 자주 일어나는 개발에서는 WaterFall Model을 적용하기 어렵다. 이렇기 때문에, 고객이 새로 Requirement를 
       바꾸는 것이 어렵다.  
       
    >> "Inflexable Partitioning" : Waterfall Model 은 Plan-Driven이기 때문에 처음부터 전체 소프트웨어에 대한 구조설계를 다 하고 시작을 하는 것이다. 
                                   핵심이 되는 부분만 Partitioning 해서 먼저 진행을 하겠다! 하는 것이 용납이 되지 않는 구조.
                                   "Distinct stage"(구분되는 스테이지) (1단계로 이거 하고, 2단계로 저걸 하겠다) 하는 것이 허용되지 않는다. 
                                   그렇기 때문에,  1~10까지 있다면 최소 해당 소프트웨어 개발에 대해 8~9 정도는 아는 단계에서 이런 개발 방법을 사용한다. 
                                   
    >> 이렇게 변화에 대해 민감하지 못한 방법론이기 때문에, 좋지 못한 개발 방법론이 아닌가 하는 생각을 할 수 있다. 하지만, 대규모 프로젝트, 큰 시스템 규모에서는 
       Waterfall 모델을 적용하지 않으면 개발 자체가 엉망진창이 될 수 있다. 해야 할 공정이 굉장히 많기 때문에, 많은 만큼 계획을 잡고 그에 대한 설계를 다 해둔 
       다음에 진행을 해야, 뒤에 가서 문제가 생기지 않는 것이다. 그렇기에 규모가 큰 개발에서 WaterFall Model을 많이 사용한다. 반면, 단기간 개발을 해야 하고 
       보다 작은 중간 규모 급들은 다 Agile 형식을 많이 취하게 된다. 
       
    >> 장점 : 역시 문제 생길 소지가 적다. / 단점 : 개발기간이 다른 개발 방법론에 비해 상당히 길다. (기본 1~2년)   
       ex) 양이 많은 과목일수록 벼락치기가 힘들 것이다. 시간적 제한이 있으면 그 제한에 따라 계획서를 짜고 미리미리 공부를 조금씩 해 두어야 나중에 그 과목에 대한 
           시험을 잘 칠수 있을 것이다. 미리 준비를 할 수 있는 것이다. 
           
       >>>> 프로젝트 덩치가 커지다 보면, 전에 했던 것을 까먹기 마련이다. 사람의 한계이다. 그러다 보니, 문서를 다 남기고 개발 단계를 거쳐가면서 개발을 한다면, 
            "어디까지 했으면, 전 단계는 안 봐도 되는" 장점이 생긴다. 그렇게 다음으로 계속 넘어가는 것이다. 
            굉장히 큰 시스템을 만들 때 그래서 유리해진다. (like 무기 체계 개발)
            
       ex2) 미사일을 개발한다고 해 보자. 미사일 하나를 만들면, 그거 하나 만든다고 끝나는 것이 아니다. 미사일을 실을 수송기, 또는 함 같은 곳에도 공간을 만들고 
            자동 제어 장치도 만들어야 한다. 그리고 관제실 또는 통신 지휘부에서도 그 정보를 계속해서 알고 있어야 하고, 반대로 통신 지휘부에서도 해당 미사일에 
            명령을 내릴 수 있어야 하는 등의 제반 사항들이 다 따라온다. 
            그렇기에, 이런것들을 유지보수하는데 있어서도 주먹구구식으로 하는 것은 불가능하다. 
                
 ** Incremental Development
  -> Specification & Development & Validation 이 유기적으로 왔다갔다 하게 된다. 
    >> 스펙 세웠다가 개발해보고, 바꾸고 하다가 개발된 거 또 테스트해보고, 왔다갔다 한다
    
  -> 그러다가 Initial Version 나오게 되면 Validation 할 수 있는 것이다. 그럼 그것으로 피드백 받고 다시 돌아가서 반복하며, 그 다음 버전을 만들수 있는 것이다.
     그러면 두 번째 버전 나오는 것임. 이렇게 3,4,5번째 버전이 계속 나오기 시작한다. 
     
  -> 이 과정 속에서 최종적으로 나오는 것이 마지막 버전이 되며, 마지막 버전까지 나오면 끝난 것이다.
  
  -> 해당 세세한 과정 안에서는 Waterfall 처럼 개발하기는 할 것이다. 하지만, 실제로 Waterfall 모델이라고 하기는 좀 그렇다. 각 단계를 왔다갔다 하는 것이라 그렇다. 
  
  -> Incremental Development의 장점 :
  
    >> 변화에 민감하게 대응하기 위해 Incremental Development 방식을 취하는 것이다. (Waterfall 모델의 방식이 변화에 상당히 약하기 때문에 그렇다)
       고객의 눈에 보이는 것을 빨리빨리 만들어내야 고객이 보면서 피드백을 줄 수 있는 것이다. 
       
    >> 유용한 Software를 엄청 빠르게 Delivery 하고 Deployment하는 것이 가능하다! Delivery와 개발이 조금 더 빨리빨리 필요할 때는 이런 개발 환경을 많이 쓴다. 
       (빨리빨리 Running Version을 만들어 내면서 Delivery(Play Store에 올리는 등))
  
    >> 과정같은 것들이 눈에 잘 안 보여서 이것저것 다 하는것 처럼 보이기도 한다. 
    >> 결과물이 나온 것을 가지고 피드백 주고, 다시 하면서 상호작용이 계속 일어나는 상태임.
                    
  -> Incremental Development의 단점 :                   
    >> Waterfall 방법에 비해서, 프로세스(얼마나 진행되었는지) 가 상대적으로 보이지 않는다.
    (WaterFall 방법은 전체적인 계획이 있어서, 진척이 얼마나 되었는지가 확인이 쉽다. 하지만, Incremental 방법 같은 경우에는 개발자 스스로도 얼마만큼 
     진행되었는지 알기 어렵다. 새로운 기능을 넣고 넣으며, 고객이 만족할때가지 개발을 진행해야 하기 때문이다. 진척률을 파악하기가 대단히 어렵다! )
     
    >> 규모가 커지면 커질수록, 해당 방법론으로는 기능을 추가하는게 굉장히 어려워진다. 맨 처음에는 기능을 추가할 것을 고려하지 않고, 짜는데 급급하게 
       코딩을 해 놓았기 때문에, 대체로 구현되고 보여주는 것 위주로 짜게 될 것이다. Unit들 간의 의존성이 높게 코딩해 놓았는데, A,B 기능 뒤에 C를 넣으려니
       A도 그에 맞게 새로 짜야 하고, B도 그에 맞게 새로 짜다보면 Refactoring 하는데 시간과 돈이 많이 든다. 
       맨 처음에 아무리 잘 정해놨어도, 그 뒤에 뭐가 들어올지 예상할 수 없는 상황이기 때문이다. 
       
       아무리 위의 단점을 막는게 개발자의 역량이라지만, 개발자가 하나부터 100까지 모두 고려할 수는 없는 노릇이다. 
       그렇기 때문에 대체로 처음부터 계획을 안 잡고 중간 중간에 추가가 되게 되면, 코드를 반드시 다시 한번 정리해 줘야 하는 과정이 필요해지고,
       이미 양이 너무 많고 규모가 커진 프로젝트에서는 그 비용이 어마무시하게 커지게 된다. 
       >>>> 그렇기에 WaterFall 모델이 Large System에서는 더 유리한 것이다. 
       >>>> Incremental 은 Middle급 정도 되는 프로젝트에서 사용한다. 
       
       
       
** Integration & Configuration        
  
  -> About Reuse : 
    >> 요즘은 Reuse하는 것이 거의 Standard가 되기는 했지만, 만들려고 하는 System에 특화된 형태로 잘 Customizing해야 의미가 있는 것이다. 
       그냥 갖다쓰게 되면 의미가 없다! 
      
    >> 시스템에 적합하게 바꾸는 작업이 이루어지지 않으면, 그 이상의 프로그램 규모가 늘어나지 않는다 )
    >> ex) sns 로그인하는 기능 / 전자결제 / 휴대폰 인증
           (이런것들을 일일이 하나하나 직접 구현하고자 하면 엄청난 코드 양이 필요할 것이다. 구현하는 것만 문제가 되는 것이 아니라, 사업자 인증
            기관등록 등등 처리해야 할 일이 너무 많다. 그냥 Reuse 하면 된다! 단, 최적화해서 ) 
  
  -> Types of Reusable Software  
    >> .NET / jdk&jre 같은 프레임워크를 잘 사용해서, 프레임워크에서 주는 API를 잘 사용하며, 이미 사람들이 많이 사용하는 코드를 많이 Reuse 하자!
        (프레임워크를 잘 쓰자)(오픈소스도 마찬가지! 잘 쓰자!)
    >> ex) 안드로이드 개발할 때, 화면 미는 기술을 일일이 구현하고있으면, 엄청 어렵기도 하고, 코드 양도 상당히 많다. 그냥 안드로이드 스튜디오에서의 
           SDK에 있는, 구현된 API들을 잘 사용하도록 하자!
            
     
** Reuse-Oriented Software Engineering (Picture Ch2.1)
  1. Requirement Specification : 스펙 정하는 것. 앞에서 이미 나와있다. 
  2. 기존에 있던 것 탐색
    2.1 Software discovery : 이미 스펙에 해당하는 소프트웨어가 있는지 찾아보는 것. 
      (똑같은 것이 있으면 좋고, 비슷한 것이 있으면 거기서 조금 본인에게 맞게끔 바꾸면 된다)
    2.2 Software Evaluation : 있는 것을 추가로 개발하는 것. 
      (이미 찾은것 말고 자기자신이 만들어 놓은것이 있을수도 있음)
      
    
  3. Requirements Refinements : 이미 만들어놓은 것을 보니까, 만약 A라는 것을 해야 되는데 A'가 존재하면, B라는 것을 해도 되지 않을까 하고 고민할 수도 있음.
    (그것이 타당하다고 생각하면, 돌아가서 다시 Requirement Specification으로 돌아갈 수도 있고, 그대로 진행할 수도 있을 것이다.)
      >> ex1) 만들고자 하는 A에서 1~5번 기능을 만들어야 한다. 하지만 4번 5번은 나중에 만들어도 될 것 같으면, 해당 부분이 중요한 부분이 아니니 4~5번은 
              "이렇게 했으면 좋겠는데~" 하고 설득해 바꿀 수도 있을 것이다. (like, 원래는 Excel로 출력해야 했는데, PDF로 바꿀 수도 있는 것임)
  
  
  4. 실제로 어떻게 Reuse 할 것인가?
    4.1 Application system이 이미 있는 경우 >> 해당 System의 Configuration 만 바꾸고 그대로 써도 될 것이다. 
    4.2 Component만 되는 경우 : 
      4.2.1 일부 Component를 업그레이드 시켜서 사용한다. 
      4.2.2 일부 Component를 발전시켜 새로 만들겠다. 
    
    >> 이후 해당 System들을 모두 통합해 새로운 System으로 만드는 것도 가능하다. 
    
 -> 이 과정이 꼭 이렇게만 흘러가리라는 법은 없다! 다양한 갈래가 있을 수는 있음!
 -> 단순히 직관적으로 봤을 때 재사용을 한다는 관점에서 보면 이렇게 설명할 수 있다.
 -> 중요한것 ! : 왜 Reuse를 해야 하는가? + 어떻게 진행하면 되는가?
 -> 어떠한 방법으로 접근하느냐에 따라서, 이 갈래는 얼마든지 많아지고 줄어들 수 있다.
 -> 중요한 것은, "있는 것을 어떻게 활용하느냐?!" 임.
 
 
 -> Reuse하는 것의 장점 : Cost & Risk를 줄인다! + Delivery가 빠르다!
     
     >> Cost : 만드는 시간이 줄었으니, 비용이 줄었다고 생각할 수 있는 것이다. 
     
     >> Risk : 잘 개발된 소프트웨어를 가지고 오면, 자기 자신이 짠 것보다 리스크가 적다. 이미 남들이 많이 사용해보았을 것이고, 그만큼 Validation이 잘 되어 있다는
               의미이다. (물론, 실력 좋은 개발자 것을 들고 오고, 그만큼 구별하는 눈도 역시 있어야 할 것이다. ) 
               일단, 그러니 Reuse할 것들은 대체로, Validation 을 자기 자신이 한 것보다 훨씬 더 많이 되어 있는 것일 가능성이 클 것이다. 
               그러므로 Risk를 줄인 것임. 
               
    >> Delivery : 이미 누가 짠 것을 가지고 와서 Reuse하는 것이기 때문에, 빠른 개발 또한 가능하다!           
    
  -> Reuse 하는 것의 단점 : Requirement의 타협이 거의 무조건 생긴다. (+ 재사용한 system element에서는 evolution 이 안 될 수 있다. 자기가 짠 것이 아니므로)
    >> Customer와 이야기를 잘 해서, 잘 풀어나가야 되는 것이다. (협의를 해야 한다)
      (이런 부분에서 보면 Incremental 방법론이 좋은 부분이 있다. 만들다가 안되면 협의하고, 고객이 인정하면 타협이 되는 부분이 있음)
      (짜다가, 고객이 생각이 바뀌어서 다르게 생각할 수도 있으니, Reuse를 많이 해서 생산성을 높이자! 빨리빨리 잘 활용해서 만들자!)
      (실제로 짜놓은 코드가 전부 쓸모없어질 수도 있음)
      
      
 ** Process Activities :
  
  1. Requirement : Requirement를 추출한 다음, 그것에 대한 분석을 시행한다. 분석을 완료하게 되면, System Description이 나오게 된다. 
      >> System Description : 우리가 만들려고 시스템이 어떻게 생겼는지, 그 자체가 그려지는 것임.
        (ex: 어떤 내용이 실제로 작성되는가? 
         Description : 이 System은 누구를 위한 시스템이고, 사용하면 무엇이 좋은지 설명됨. 그래서 ~~~~를 하려고 한다!) 
         Requirement : 사용자가 ~~~한 기능을 수행할 수 있고, 시스템은 ~~~ 기능을 제공해야 한다. (설명서)) 
          (like : "시스템은 로그인/로그아웃을 지원해야 하며, 10분 이내로 로그인이 종료되어야 한다" 와 같은)
  
  
  1.1 Requirement Validation : Requirement 사이에서도 서로 안 맞는 내용이 나올 수 있다!
      >> ex) "고객은 한 장소에서만 로그인이 가능하다" with "한명의 사용자가 pc와 모바일에서 같은 주문을 확인할 수 있다"
            >>>> 모순임. 둘중 하나를 고치던치, 케이스별로 나눠서 하던지 해야 함. 
            >>>> 요런 것 검증을 꼭 해야 한다!
  
  
      >> 요런 것들을 막기 위해서 Requirement Validation 이 필요하다! Requirement 간에 충돌이 생겨버리면, 다른 하나는 못 구현하기 때문.
      >> 이 단계가 끝나면 완전한 Requirement Document가 나오게 된다. 
  
  
  2. Software Design & Implementation 
      >> 이에 앞서, 우리가 할 것들에 대한 어떤 여러 가지 Target들을 다 정의하게 된다. 
      >> Item 1,2,3 가 있다면, 각각의 Item을 어떤 식으로 구현할 것인가에 대한 의미가 Design이다.(구조를 어떻게 잡을 것인가?!)
      
      ex) 기존의 수강신청 + 수강꾸러미 기능 넣기
        >>>> 기존에는 수강신청 날 바로 수강신청을 했는데, 수강꾸러미 라는 제도가 들어가게 되면, 꾸러미 정원이 넘는지 안 넘어가는지도 체크해서 자동으로
             수꾸 안 터지는 것들은 수강신청이 되도록 해야 하며, 정원이 넘어가면 수강신청을 하게 만들어야 한다. 
      
      >> 이런 "수강꾸러미" 와 같은 기능이 하나 있고 없고에 따라 "수강 신청"에서의 전체적인 Mechanism이 바뀌게 된다!
          >>>> ex) 수강꾸러미로 수강신청이 된 과목인가 아닌가에 대해 비교하는 Logic 추가
                   정원이 넘친지 아닌지 확인하는 기능
                   넘치지 않은 과목에 대해서 자동으로 수강신청하게 해주는 Logic
                   
          >>>> 이렇게 되면 당연히 전체적인 설계가 달라질 수 밖에 없다. 
          
      2.1 Design Process에 있어서 일반적인 Model
        
        2.1.1 Design Output
        >> 결과물에 System Architecture, Database Specification, Interface Specification, Component Specification 있을 것이다. 
        -> 이런 것들을 보고 "System 설계서" or "Software 설계서" 라고 부름. 하나의 Architecture로 묶여져 있을 수 있다. 
        (물론, 저게 다 있어야 된다는 것은 아니다. 만약 DB가 들어가지 않는다면 DB가 없을 것임)
        (System Architecture 정도는 있어 줘야 함. 그래야 전체적인 시스템을 이해하는 데 이해가 될 것이다.)
        (Component Spec 정도는 보통 있어야 하고, Interface Spec 까지 Design에 있으면 좀 상세하게 적은 것이라 할 수 있다)
        (Component Spec -> 들어가는 여러가지 Component들이 어떤 것들이 있고, 어떤 역할을 한다는 것 정도 있어 줘야 세부 구현이 가능)
        (Interface Spec 있으면 Component간의 관계에 있어 어떻게 상호작용하는지 알게 되니까 더 좋다)
        
        2.1.2 Design Input 
        >> Requirement Spec : 앞에서 했던 설계. 제일 중요하다. 
        >> Data Discription : 어떤 데이터가 어떤 데이터 타입을 갖고있는지? 중요하다. 
        ex) 숫자가 입력이 문자로 들어오고 있으면, 이런것들 처리하는데도 뒤에 것들을 다 바꿔야 하니 일손이 많이 들어갈 것이다. 미리 정하고
        들어가면 제일 좋다. 
        >> Platform Information : 도데체 "어디서" 동작하는가? (PC에서 돌아가느냐, 안드로이드에서 동작하는가?) 
        -> 이것에 따라서 설계가 완전히 달라지기도 한다. 
        
        2.1.3 Design Activities : 
        >> Architecture : 어떤 큰 틀로 만들어질 것이냐? 
        >> Interface Design : 어떤 입력방식으로 동작하냐? 어디서 출력하냐?
        >> Component Design : 위에서 한 것들을 가지고 세세한 Component들을 만들고, 디자인함. (크게 Class 설계라고 보면 된다)
        >> DB Design : 마지막에 DB를 디자인한다. 다 나온 뒤에 DB를 설계하면 어떤 애들을 어떤 부분에 넣을지 1대 1로 설계가 가능하다. 
              (원래 앞의 내용들은, DB를 어떻게 사용할지 염두에 두고 앞의 내용들을 먼저 설계하는 것이 좋다)
        ex) 카카오톡 : 
            - 인트로 있을 것임.(바뀌기도 하고, 이벤트들도 있을 수 있다)
            - 메인 레이아웃(친구창, 채팅창, 더보기, 설정)
            - 조금 더 디테일한 사항들(이 항목들은 어떤 일을 합니다!) // Architecture
            
            - Interface : 카톡은 휴대전화에서 터치로 동작한다. (누르고 있을 때, 눌렀을 때 다 다름, 꾹 누르면 삭제, 관리 등이 나옴.) -> 요런 사항들 관리
            - Interface Design(상세) : Component 사이에서의 전환이 이루어지면 어떻게 효과를 줄 것인가? 어떤 명령을 내리면 어떻게 넘어가나?
            (인터페이스 디자인은 높은 추상화 레벨에서 돌아가는 것이다. 코드에서의 인터페이스 단계는 아니지만, 거기까지 가도 문제는 없다)
            
            (최대한 상위 레벨에서 점점 깊게 들어가는 단계이다) (Top-down으로 내려갔다, Bottom-up으로 올라오는 것임)
            
            - Component Design : 위에서 했던 것들을 가지고 세세한 Component(Class)를 만들고, 디자인. 
            
            (하면서 세부 인터페이스를 설계하고, 인터페이스를 구현하기 위한 Class도 필요할 수 있을 것이다. 해당되는 애들을 설계)
            
        >> 꼭 이렇게 정형화 되어야 하는 것은 아니다! (DB가 없으면 빠져야 할 것임)(일반적인 <가이드라인>은 이렇다!)
        >> 하지만, 절차대로 설계하는 것이 제일 좋다! 먼저 System Requirement를, 최대한 문서 안에 있는 애들을 다 뽑아내면서 다 잡아내고
          그다음에 Architecture, Interface Design, Component Design, DB Design 식으로 잡아주면, 문제없이 효율적으로 할 수 있을 것임. 
          (+ 있어야 할 애들이 없으면, 다음 단계로 진행이 불가능할 수밖에 없다. Requirement Spec, Data Discription, Platform Information
          중 하나라도 없으면, 만들수 있는 것이 대단히 제한적일 수 밖에 없다)
      
  3. Programming(구현) >> 그냥 일반적으로 하듯이, 위에 것들을 다 잡고 구현을 하면 된다. 본인 스타일대로 하는것이 제일 효율이 좋다. 
        
  4. Software Verification & Validation  : 
    4.1. Verification  
      >>앞서 나왔던 스펙들과, 만들어 놓은 프로그램의 스펙을 1:1로 비교하는 것이다. 
    
    4.2. Validation 
      >> User Requirement와 맞는지 비교하는 것임. 스펙과 1:1로 매칭되는 것이 아니다. Spec상의 Requirement 여러 개가 User의 요구사항 1개일 수 있다. 
      >> 반대로 User의 요구사항 여러 개가 Requirement 하나로 귀결되어 정해질 수도 있는 것임. 
      >> 쨋든 잘 맞는지 Requirement와 비교하는 것이다. 
      
   5. Testing     
    -> Component Testing, System Testing, Customer Testing이 있다. 물론 이 전단계의 테스팅도 있지만, 그것들은 개발단계에서의 Testing
       이기 때문에 여기에는 포함하지 않는 것으로 한다. 틈틈히 테스팅해보면서, 안맞으면 다시 그 위의 단계들부터 왔다갔다 해야 하기 때문. 
    
    5.1 Component Testing :
      >> 각 클래스들을 서로 유기적으로 연결해 보아 테스팅하는 것. 이 클래스 저클래스 다 불러서 호출해보면서, 테스팅하는 단계
      (일반적으로 하나의 Component = 하나의 Class!)(클래스 내의 메소드들을 다 부르면서 테스팅하는 단계이다)
      
    5.2 System Testing :  
      >> 여기서부터는, 흔히 말하는 "Spec Based Testing"을 한다. Compound끼리 다 연결해서 테스팅해 보았으면, 하나의 시스템이 된 것이다,
      >> 하나의 시스템을 전체적으로 테스팅하는데, 시스템을 만든 이유인 "스펙"과 비교하면서 테스팅하는 것이다.
      >> 이것을 만족하면 System 테스팅이 되었다고 말할 수 있는 것이다. 
      
    5.3 Customer Testing(Acceptance Testing) 
      >> 유저한테 직접 보여주면서 확인받는 것. 유저가 Accept하면 오케이임. 
        ex) 스펙에서, "100시간 동안 시스템이 죽어서는 안된다!" 라고 한 소프트웨어를 테스팅받는데, 95시간 째 죽은 것을 확인함. 
            (그 전 테스팅할때는 안그랬는데 >> 데모의 저주)
            근데 유저가, 50시간쯤이면 되었는데 빡빡하게 100시간 찍었다! 이정도면 오케이다~ 라고 한다면, 그냥 출시하면 되는 것이다.
            근데, 다른 것도 다 안되면, 당연히 여기서 오케이 받을 수는 없을 것임. 
           -> 이래도 고객이 "받아들일 수 있는 수준" 이면, 오케이 된다~(유저가 본래 원했던 스펙 수준보다, 출시되는 것들이 대부분 약간씩 낮다)
           
            
    
      
    
    
