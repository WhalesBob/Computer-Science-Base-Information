< 5장 : System Modeling >

 ** 목차
     - Context Models
     - Interaction Models
     - Structural Models
     - Behavioral Models
     - Model-Driven engineering
     
     
 ** System Modeling이란?
    
      >> System Modeling = 추상화!
          -> 함수는 가장 작은 형태의 "모델링" 이다. 
      
      >> 그럼 "추상화"(System Modeling)를 어떻게 할것인가?
          -> 우리가 만든 시스템이 "어떤 동작을 하는 시스템이다!" 라는 것을 정의해 가고,정하는 것이 Modeling이다.
          -> System Modeling은 "System을 어떻게 동작시킬 것인가" 를 만들어 나가는 "과정" 이다. 
              ("이렇게 쓰는거에요" X, "개발하는 과정" O)
              
      >> UML(Unified Modeling Language)를 통해서 표현한다. UML은 대부분 어떤 "기호" 들로 이루어져 있음. 
      >> Modeling은 이미 있는걸 써도 된다. 굳이 새로 만들필요는 없음. 그냥 있는 것을 쓰거나, 조금 더 개선시키는or진화시키는 방향으로 해도
         괜찮다.
         
    *** Existing and Planned System Models   
      >> 이미 존재하는 System에 대해서 모델링하는 것은 쉽다(이미 존재하니까). 이미 어떤 시스템이 존재하고, 그것에 대해 어느정도 다 알고
         있으며, 어떤 동작하는지, 어떤 구성이 되어있는지 다 알기 때문임.
      >> System Modeling은 주로, Requirement Engineering할 때(Requirement 분석할 때) 개발자들이 하고 있는 행위가 어떻게 보면
         System Modeling이라고 할 수 있을 것이다. 
      
      >> 우리가 알고 있는 사실로부터, 사용 시스템에 대한 Requirement를 뽑아내는 것이 가능하다(System Modeling에서)
      >> 새로운 System같은 경우에도, Requirement Engineering 할 것이지만, 기존에 있는 것들과는 다르게 Prototyping해서 보여주는 과정이
         필요하다. 그래서 Prototyping 하는 것도 일종의, 아주 Rough하게 만든 System Modeling이다. (Requirement를 아무리 글로 적어줘도
         모르니, 다른 Stakeholder에게 보여주려고 만든 것이다. "Model"을 만들어가지고 보여주면 "이런것이군!" 하고 이해할 수 있다.)
          -> ex: 모델하우스 : 집이 아니지만, 집이 어떻게 구성되어 있는지 알게해준다.            
      
    *** System Perspectives
      >> 바라보는 관점도 대단히 많다. External / Interaction / Structural / Bahavioral 
      >> External Perspective : 시스템을 외부에서 바라보았을 때, 시스템이 어떻게 동작해야 하는가? (Context Model이라고도 이야기함)
                                (context : 맥락, 전후사정. context를 environment로 바꿔써도 여기서는 말이 된다)
                                
          -> ex : 차량 시스템. 군납하는 차량 중에 산을 올라가야 하는 차량을 일반 상용차랑 똑같이 만들면 안될것이다. 
                  왜냐하면, 차를 둘러싸고있는 환경, 맥락이 다를 것이기 때문이다. 상용차는 포장된 도로 위를 달릴 수 있게 만들면 되는
                  반면에, 군용차는 산위를 오를 수 있게 만들어야 하기 때문이다. 그에 맞게 더 보강하거나, 구조를 바꾸어 만들어야 한다. 
                  
          -> 요런 요소들을 고려해야 하는 것이 External Perspective. 해당 차가 돌아가는 System을, 외부에서 바라본 것이다. 
          
      >> Interaction Perspective :  System과 environment, context와 System 간에 interaction하는 측면. 여기서 "환경"은 "사람"도 포함.
                                    왜냐 하면, 시스템 입장에서 보았을 때는, 외부적인 요소이다. 사람이 어떤 Action, Event를 주게 되면
                                    System이 이를 받아들이고, 또 다른 Action을 취할 것이다. 
          
          -> ex : 에어컨의 입력정보는 온도, 습도 등이다. 환경이 에어컨 시스템에 정보를 주고 있음. 
                  그럼 온도와 습도를 받아들인 시스템은, 다시 동작해서(냉풍, 온풍 방출 등) 외부에 Action으로 다시 output을 내는 것.
                  그럼 그 output action은 환경에 영향을 미친다. (Embedded System에서, Closed Loop System이라고 불리는 것)
                  
          -> 요런 상호작용의 관점에서 보는 것이 Interaction Perspective. 
      
       ( External 관점에서도 System을 설명할 수 있을 것이고, Interaction 관점에서도 System을 설명할 수 있을 것임. 하지만 그 설명은
        당연히 다 다를 것이다. ) 
         
      >> Structural Perspective : "어떠한 형태로, 어떠한 조직으로, 어떤 것을 하는 것으로 만들어야 한다" 라는 관점.
          -> ex : 바퀴는 어디든 갈 수 있는 바퀴로 만들어져야 하고, 사람도 많이 탈 수 있는 형태로 만들어 져야 한다
          
       ( 결국 다 같은 이야기. 설명하는 시야에 따라서, 관점에 따라서 설명하는 방법이 달라질 뿐이다. 같은 것을 설명하더라도, 이런 모든
         관점을 다 알아야 한다. 다양한 측면에서 보고, 다양한 측면에서 설명되는 모든 것들을 다 포함해서 보아야 함! )
      
      >> Behavioral Perspective : 어떻게 행동하는가를 보고 이야기하는 것. 
          -> ex : 군용차는 울퉁불퉁한 길에도 흔들림 없이 달려야 한다. (와 같이 기술됨)
          
          
      >> 초원 길에도 흔들림없이 달려야 한다고 얘기하면, 바퀴가 아니라 무한궤도인 형태로도 만들어질 수 있을 것이다.
         하지만, 단순히 Behavioral Perspective 측면에서 보았을 때 그렇다는 것이지, External이라던지, Structure 관점에서 보았을 때는
         반드시 우리가 아는 둥근 형태의 바퀴가 달려야 한다는 것을 알 수 있음. Behavioral 관점과는 또 다르게 시스템이 구현되어야 함.
      
      >> 이런 관점들이 서로 맞물려서 설명될 수 있다. 이런 관점들을 다 이해해고 활용할 줄 알아야 System에 대한 Modeling이 가능하다.
      
         
    *** UML Diagram Types ( 이 타입들은 다 알아두기! )        
      
      >> Activity Diagram : 위에서의 Context를 설명함. 시스템 외부에서 보았을 때, 어떻게 처리하는 것처럼 보여지는가?!
      >> Use case Diagram : 기능적인 부분. 어떻게 Interaction하는지는 모르지만, 어떤 Interaction 하고있는지는 알 수 있게.
          -> Actor가 System에서의 어떤 기능을 사용할 수 있다! (와 같이) / 반대로 System의 경우에는, "환경"에 어떠한 기능을 제공한다와 
             같은 형태에 대해서만 기술되기도 한다.
          
      >> Sequence Diagram : Interaction을 상세하게 표현해주는 Diagram. 
          -> ex : Sequence에서는 함수 A 내부에서 어떤 것을 호출하는지 다 보여줘서 그 관계들을 다 파악할 수 있음. 반면, Use case의 경우
                  사용자가 A라는 함수를 호출해 어떤 결과가 나오게 되는지만 알 수 있음.
          
          -> Use case를 조금 더 상세하게 풀어내면, Sequence Diagram으로 풀어낼 수 있다.         
      
      >> Class Diagram : 클래스, 객체 단위로 시스템을 뽑아내어 객체 간의 연결, 구성들을 보여주는 것.
      >> State Diagram : Behavior 측면에서 설명하는 것처럼, 시스템이 내부/외부와 어떻게 행동하는가를 보여주는 다이어그램.
                         어떤 입력이 들어갔을 대 어떤 출력이 나와야 하는지만 알려줌.
                         
          -> ex : 냉난방기의 경우, 냉방 모드에서 25도를 맞춰 놓으면 냉기를 내뿜겠지만, 난방 모드에서는 온기를 뿜을 수 있을 것이다.
                  같은 입력값, 같은 이벤트가 발생해도 다른 Action을 취하는 것이다.         
          
 ** Context Models
      
      >> System Boundary 외부에 있는 것들에 대해서 다룸. 
      >> System이 어떻게 행동할지는 모르겠지만, 어디에 쓸지, 누구에게 쓰여질지, 어떤 입력을 줄지, 어떤 기능을 요구할지와 같은 
         주변 환경은 안다!(어떤 Output이 나와야하는지도!)
      >> 시스템이 사용되는 상황적인 "문맥"을 이해하고, 그런 관점에서 시스템을 바라보는 것임. (System 내부적으로 어떻게 생긴지 몰라도
         설명가능하다) ( ex : 함수를 짜기 전에도, 어떤 인풋을 줄지, 어떤 아웃풋을 내야 하는지 미리 아는것처럼. 그냥 그렇게 나오면 된다 )
      
      >> 요런 Model을 보고 Context Model이라고 한다!
 
      >> Example : Mentcare System (그림 5.1)
          -> Mentcare System 안의 내부는 몰라도, 주변에 정보를 주고받을 다른 System들이 존재한다는 것은 알고 있다.
          -> 1. 환자 기록 System이라는 외부가 있으니, 이 외부 System으로부터 받아오면 된다는 것은 알고있다. (없었으면 이 시스템에서 
                다 만들어내서 처리했어야 함)
          -> 2. 1번에서 처리한 결과를 Management Reporting System으로 주면 되는것은 알고있다. (간호사들은 보고 진료결과 알려주면 됨)
          
          -> 전반적으로 이렇게 볼 때, 이 Mentcare System이라는 것은 주변 System과 연동되어 중앙에서 정보를 처리해 주는 애라는 것을 
             알 수 있음. 
          -> Context Model에서는 이런 외부의 상황을 먼저 고려한다! 시스템을 어떻게 만들지. 내부적으로 어떤 처리를 해줄지는 먼저 외부를
             먼저 보고 난 뒤에 나와야 함. 

      >> 항상 외부의 필요에 따라서 만들어지는 것이라는 것을 명심하는 것이 좋다! 아니면 개발하면서 뻘짓할수도 있음.
          
     << 번외 >> :
          -> Software를 처음에 구상할 때는, Top-Down 방식으로 짜는 것이 좋음. 물론 Bottom-Up 방식으로 짜도 되지만, 그런 경우에는 대체로
             이미 다 알고 있는 이야기일때 그렇게 한다.
          -> Top-Down은 중간중간에 필요할 것 같은 것들을 추가하게 된다. 하지만 Bottom-Up 의 경우에는 그게 힘들다. 
          
 
    *** Process Perspective
      
      >> Context Model의 경우, 해당 System이 속해서 동작하게 되는 전체 환경을 이루고 있는 주변 "다른 System"들만 보여주면 된다.
          (외부만 보여주면 된다). 
          
      >> ex : Mentcare System
          -> 그림 5.1에서의 외부 시스템이 아예 없다고 치면, 필요시 같이 만들어야겠다고 필히 생각할 것이다.
              (System이 가지는 Boundary를 개발자들이 정하는 것이다. 그림 5.1에서, 만약에 외부 시스템이 하나도없으면, 
              다 만들어야 할 것이다. 다 필요한 내용들이기 때문.)
          -> 외부의 것들이 다 있다고 한다면, 그 외부의 System이 어떻게 동작하는건지는 알빠가 아니다. 얘들한테 뭘 제공받는지만
             신경쓰면 될 것이다. (이런 것만 보면 Activity Model과 겹친다)
 
 
    *** Process Model of Involuntary Detension ( Activity Model 예시 )
    
      >> 예시별로 다이어그램 따라가야 함. 
      >> 흐름을 보면 된다. 
      >> "이 시스템이 어떤 역할을 한다!" 라는 것을 보여주려고 만드는 느낌.
      
      
      
 ** Interaction Models     
       >> Use case / Sequence Diagram 두개가 Interaction Modeling에 사용된다.
       >> User Interaction Modeling ( User Interaction을 확장하는데 도움을 준다 / 사용자에게 필요한 내용들을 알려준다)
       
    
    ***  Use Case Modeling
       >> Use case : "사용 예시" ( 이런식으로 사용이 된다! )
       >> Requirement Elicitation(추출) 할 때 필요하다. 
       >> Actor는 사람 혹은 다른 시스템으로 표현된다. 
          -> Actor가 꼭 사람일 필요는 없다. 시스템일 수도 있고 컴퓨터일 수도 있다. (원래는 User라는 말로 많이씀)
          -> User의 경우 사람의 의미를 더 담고 있는데, Actor의 경우 User의 개념을 포함하는 더 큰개념.
          ex) 일반 계정으로 로그인하는 것과 유료 계정으로 로그인할 때 제공되는 시스템, 서비스가 다를 것이다.
              하지만, User라고 하게 되면, 똑같은 "User(사람)" 이기 때문에, 위의 예시의 계정차이를 담지 못할 것이다.
              그래서 Actor라고 함.
              
          -> 똑같은 사용자가 여러 Actor 일수도 있음(다른 역할을 하는 계정 여러개) 
          
       >> Ex : (Mentcare System, Transfer-Data Use Case)
          -> Use Case 그림에서 선은, "A"와 "B" 가 관련있다 정도의 의미를 가진다.
          -> 단순한 그림(17p/58)을 상세한 Description(18p/58) 로도 나타낼 수 있다. 
          -> 사람(Actor)가 있고, 역할이랑 연결되어 있으면, 맥락상 할수 있는 것들을 할 수 있을 것이다(19p/58)
 
    ***  Sequence Diagram
       >> Use Case에서 보았던 그림, 그리고 해당 Actor가 할 수 있는 것들을 함수 단계까지 디테일하게  보는 것임.    
       >> (그림 5.3, Sequence Diagram for View Patient Information) : 
          
          -> 순서대로 Sequence를 나타낸 그림. 그림 5.3 식으로 Sequence Diagram을 그린다.  
          -> Actor만 사람처럼 표시하고, System은 네모박스로 표시한다. 
          -> 이 그림을 통해, 일의 flow가 어떻게 동작해야 하는지, 클래스 간의 관계가 어떻게 되는지 파악할 수 있다.
                (물론, 이 그림은 함수들이 가진 기능의 "일부"만 표시한것임. flow에 맞게)
                (다른 기능도 다 적어 들어가버리면, 어떤 기능이 그에 맞게 나오는지 헷갈릴 것이다)
                (해당 기능에 대해서, 딱 하나의 Sequence만 알려 주는 것이 Sequence Diagram이다!!)
                
       >> "대충 이런식으로 동작하는구나!"를 Sequence Diagram을 보고 알 수 있음. 하지만, 이것만 보고는 전체 클래스가 어떻게 동작하는지
          는 알 수 없다. 이런 것들은 Class Diagram이 보완해준다. 그래서 Use Case/Sequence Diagram/Class Diagram 세 개만 보면
          서로 보완관계에 있기 때문에 설계에서의 대부분의 과정이 모두 들어간다. 설계할 때 다 만들어 놓는 것.
          (이렇게 안만들어놓으면, 이 과정이 모두 뒤죽박죽 섞여있다)
          
        
 ** Structural Models
       >> 그냥 쉽게 말해서, "Class Diagram"이다. (자바에서의 그 Class!)
       >> Class 가 모이면 Component, Component가 모이면 System이 된다.
       >> 전체 구조를 구조적으로 어떻게 Modeling할 것인지, Class를 어떻게 만들고 배치할 것인지, 어떤 관계를 서로에게 부여할 것인지
          정하는 것이 Structural Model의 핵심이다!!
          
       >> Top-Down 방식으로 생각하면 된다! 
          -> 하나의 System 안에는 여러 개의 Sub-System이 있을 것이고, 그 Sub-System을 어떻게 구현할지 생각해보면, Component가 나올 것임.
          -> 이렇게 System들을 연결하고 보면, Context-Model이 나올 것이다. 그럼 Sub-System 안에서의 Interaction이 나온다. 
               (전체 System 관점에서 보았을 때, 내부적인 구조가 나오는 것이다)
          -> 이렇게 계속 쪼개지면서 계층적으로 계속 나아가는 것임. 더 깊이 들어가면 Class 까지 가게 될 것이다!
          
    *** UML Classes and Association
       
       >> Class는 네모박스치고, 실선으로 연결되어 있으면 그냥 "관계가 있다" 정도의 수준.
       >> 숫자 1 : 1 이면, 해당 A 객체당 B 객체가 하나씩 연결되어 있다는 뜻.
       >> 1...* 은, 1 이상의 숫자라는 뜻임.
       >> 얘도 역시 연결된 것을 보고 파악하면 된다.
       
    *** The Consultation Class(28/58) : (27p를 단순히 단어(필드와 메소드) 로 나타내 놓은것)   
       >> Field : Attribute(속성)
       >> Method : Operation(동작). 
       >> 이름만 있을 수도 있고, 타입까지 같이 있을수도 있음.
          
          
    *** Generalization : Java에서의 상속관계. extends! ( Is - a 관계 )
    
    *** Object Class Aggregation(집합, 집단) Models ( Has - a / Is part of ~ )
       >> Aggregation : 구성, 파트. ~의 일부분. A is part of B(A가 B에 속한다!)
       >> ex : (The Aggregation Model) (34p / 58)
          -> Patient Record 안에는 꼭 1명이 Patient가 포함되어야 한다. 
          -> Patient Record 안에는 1개 이상의 Consultation 기록이 포함되어야 한다.


 ** Behavioral Models
        
        >> 실제로 시스템이 어떻게 동작하느냐에 따라 정의하는 것.
        >> 이전에 Structural Model의 경우에는 Class Diagram / Functional(Interaction) Model의 경우에는 Use Case로 나타내었다면, 
           Behavioral Model의 경우에는 State Diagram으로 주로 표시한다. 
           
        >> State Diagram :
           -> 입력에 따라 결과가 당연히 다르게 나오게 된다. 이 "입력"에 따라, "Event"가 발생했을 때 당연히 다른 결과를 낸다.
                ex : 만약 점심을 거르는 event가 있을 때, 배가 고픈 상태에서 점심을 거른 것과 배가 부른 상황에서 점심을 거를 때의
                     결과는 당연히 다르게 나온다. 
 
           -> Behavioral Model의 경우, 항상 "상태"를 먼저 이야기하고, 이런 상태일 때 어떤 "Event"가 발생하면 어떤 결과가 나온다! 
              식으로 흘러감. 그 결과가 또 다른 "Event" 모습을 하고 있을 수도 있다. 
              
        >> 두개의 Type으로 생각해볼 수 있다.
           -> Data : Process가 진행됨에 따라 Data의 움직임.(System 안의 Sub-System들이 서로 데이터를 주고받는다)(실질적으로 주고받는 Data)
           -> Event : Data도 Event라고 볼수 있기는 함. (이때의 Data는 Trigger.) (위에서의 "점심을 거른다" 와 같은 event 같은 느낌인듯?)
                    
    *** Data-Driven Modeling
        >> 시스템 에어컨이 동작할 대, 현재 온도가 몇도냐에 따라 냉/난방 모드에 따라 냉기를 방출할수도, 온기를 방출할 수도 있다.
           모든 것들은 Data화 되어 처리되는 것이다. 모든 것들을 데이터, 수치화해서, 그 데이터가 어떤 값이냐에 따라 동작하는 것이 
           달라진다.
           
        >> 온도가 실수일 때, 오름으로 처리할지 내림으로 처리할지, 반올림으로 처리할지는 알고리즘에 따라 달라지는 것이다.
        >> 그냥 오로지 들어가고 나오는 데이터에 따라서 생각하면 간편하다. 일단 복잡한 시스템의 경우, (본인이 짠게 아니라 API라면)
           그냥 "입력에 따라서 출력이 나온다" 고 생각하면 되는 것이다. "제공하는 데이터와, 그로 인해 가질 수 있는 데이터" 만 생각하는
           식으로 접근하면 쉽다. 
           
        >> 이런 식으로 시스템을 단순하게 볼 수 있다!
        >> ex : (An Activity Model of the Insulin Pump's Operation) ( 그림 5.4 )
           -> 그림의 과정대로 일이 처리가 되는 것이다. 중간중간에는 어떤 데이터를 집어넣고 어떤 데이터가 나오는지만 보면 되는것이다.
           
    *** Event-Driven Modeling
    
        >> Data에서도, 넓은 범위로 Event를 중심으로 보는 것이 Event Modeling이다.
        >> Data Driven의 경우에는 입력된 데이터에서, 반드시 기록된 데이터가 있어야 함. 그래서 데이터의 연결이 끊기지 않고 쭉 이어짐.
        >> Event Driven의 경우, Event가 동작할 때만 무엇인가가 일어나는 것이다.
           -> ex) 웹 서비스 :  클릭할 때마다 무엇인가가 실행되고, 동작하는 것이다.
           -> ex2) Real Time System( Embedded System ) : 버튼을 눌렀을 때 켜지고, 어떤 버튼을 누르면 모드가 바뀌고, 
                                                         어떤 모드일 때는 온도를 올리는 동작을 하는 등의 이벤트들이 다 있다.
        
        >> Event의 경우에는, 외부의 Event, 내부의 Event 를 구분해서 사용함. (무엇이 중요할지는 시스템마다 다르다)
             ex) 외부에서 내부의 시스템이 돌아가는 것을 간섭하면 안된다고 이야기하지만, 동작하다가 외부에서 꺼짐 버튼을 누르면
                 꺼질 수도 있는 것임. 이러면 외부의 Event가 더 중요함.(내부에서 이런 외부의 Event를 대비해야 함)
        
           
 
 
 
 
 
 
 
 
 
    
 
 
 
 
