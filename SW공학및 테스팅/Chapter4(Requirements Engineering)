< 4장 : Requirements Engineering >

  ** 목차
      - Functional and Non-Functional Requirements (두개를 어떻게 구별할 것인가?)
      - Requirements Engineering Process (Requirements를 작성해 나가는 방법)
      - Requirements Elicitation (Requirements 끌어내기)
      - Requirements Specification (스펙을 만들어 나가는 방법)
      - Requirements Validation ( Requirements 검증)
      - Requirements Change
      
      
    *** What is a Requirements(그래서, Requirements란 무엇인가?)
      >> 두루뭉실하게 되어 있는 것은 Spec이라, Requirements라 이야기하지는 않는다.
      >> 정확하게, 자세하게 기술되어야 한다. 문장으로 표현되는 경우가 많다. 
      >> 주고받는 형식 또한 있음. 

    *** Requirements Abstraction(Requirement 개요)
      >> Customer의 Need, Customer가 필요로 하는것이 어떤 것이다 라는 것을 굉장히 큰 틀에서 정의하고 시작하게 됨.

    *** Types of Requirements  (User vs System)
      >> User Requirements 
        -> 고객이 필요한 것. 사용자 입장에서든, 운영자 입장에서든, "User" 입장에서 보았을 때 필요한 Requirements
        -> 자연어나, 다이어그램 등의 형태로 많이 기술된다. 
        -> 사용자가 특정한 범위의 사용자일 수 있음. (ex:20대 남성, 이런 식으로 한정해서 생각할 수 있음.)
        
      >> System Requirements
        -> 주로 Diagram, 자연어보다는 Document로 해결을 한다. (부정확하게 기술되면 시스템이 정확이 어떻게 동작해야 하는지 잘 모르는 경우
            가 많다). 
        -> Detail Description이 필요함! 
            ex) 단순히 로그인에 대해서도 상세히 기술해야 함.
                - 지문 인식, 안면 인식, ID 사용, SNS 로그인 등 할 수 있다. 
                - ID의 경우에는 몇 자 이상 몇 자 이내로 해야 하는지 등 --->> 구체적으로 기술이 되어야 한다!!
                
    *** User and System Requirements(예시, 그냥 보고 넘겨도 ㄱㅊ)
      >> User Requirements : 한줄임. 그냥 사람이 하는 말처럼 구현해 놓음. ~~~한거 해주세요!
      >> System Requirements : 엄청 상세하게, 어떨 땐 어떤 기능을 해야 한다는 것을 적어 놓음.
      
      >> 개발자는 User Requirements에서 System Requirements를 뽑아 내야 한다!
      >> 고객이 이렇게 System Requirements처럼 주면 제일 좋지만, 대부분 그렇지 않다. 그래서 User가 저렇게 한 마디 해 주면 개발자는
         이런 내용들을 말로, 혹은 문서로 기술해서 다시 보여줘야 함. 
         -> 만약 그냥 위의 작업 없이 WaterFall로 하면, 제품 만들고 나서 나중에 보니, "이렇게 보니 아닌것같다. 바꿔줘!" 할 수 있음
         -> 만약 이렇게 정해진 것이 없다면, 이런 Requirements를 뽑아내기 위해서라도 Prototyping이 필요한 것이다 .
            (프로토타입을 만들어서 눈에 보여주는 것임)
            
    *** Readers of Different Types of Requirements Specification (누가 보느냐?)
      
      >> User Requirements 
          -> 클라이언트 매니저(고객관리, 고객담당)
          -> System End-Users(실제 사용자. 사용하는 사람이, 자기가 이야기한 Requirements가 맞는지 확인)
          -> System Architectures
      
      >> System Requirements
          -> System End-Users(사용하는 사람이 한번더 보게 됨)
          -> Client Engineers
          (개발자(Developer)가 이런 User Requirements를 볼일은 별로 없음. 프로젝트 매니저나, 고객과 소통하는 사람들이 User Requirment
           확인하고, 일반적인 말단 개발자는 User Requirements가 크게 고려대상은 아니다)
          ( System Requirements가 다 정해져 있는 상태에서, 설계하고 개발해 나가는 것이다)
          ( User Requirements : 기획하는 쪽 / System Requirements : 개발자가 시작해 나갈때 필요한 것)
          
    *** System Stakeholders(이해당사자)
      >> End User
      >> System Manager
      >> System 소유주 ( 주로 의뢰를 맡기는 쪽. 물론 본인이 쓸거면, End User와 System 소유주가 동일인물이 된다)
      >> 외부 관계자
          
      >> System이 커지는 것보다, StakeHolder가 많아지는 경우가, 더 상황이 복잡한 경우가 많다.
         -> 사용자는 깔끔한 UI를 원하는데, 관리자들은 한번에 펼쳐놓고 복잡한 정보들을 한 눈에 다 볼수 있는 경우를 원하는 경우.
           (이런것때문에 관리자 페이지와 사용자 페이지를 따로 만듬)
           (현실적으로 불가느하면, 둘중하나로 타협을 해야 함)(Stakeholder 들이 있으면, 이런 것들을 고려하는 것이 제일 힘듬)
           
    *** Agile Method and Requirements 
      >> System Requirement 같은 경우, Detail하게 기술해야 한다. 
         -> 구체적이지 않으면, 해당 부분에 대해서 개발자가 상상해서 구현해야 함.만약 Customer가 그것을 원한게 아니면 그 다음부터는 힘들어짐.
      >> Agile 방법에 있어서는, 구체적인 Requirements보다는, 완전 상세한 Requirement보다는 어느 정도까지만 Detail하게 뽑고, 
         Requirement 만드는데 그렇게 많이 시간을 쏟아서는 안된다.(정도껏 해야함) 당장 코딩하기도 바쁜 방법임!
           (절충선을 개발자가 잘 찾아서 진행해야 함)
           
      >> Requirement 문서도, System Requirement같은 경우 대부분 문서로 만들어지는데, Agile에 있어서는 이것도 최소화해야 함. 
      >> Agile 같은 경우, User Story(Senario)를 가지고 User Requirement를 표현해내야 하고, Requirement안에 User Story를 포함시켜야 함.
      >> 물론, User들이 User Requirement를 바로 제공하는 경우는 별로 없다. 그냥 "~했으면 좋겠어요!" 하고만 이야기하고, 개발자가 그 부분에서
         User Requirement를 뽑아 내야 함. 
         
      >> User에게 계속 확인시키면서 수정해 나가야 함. 그렇게 정하고 나서 Confirm이 나오고, System이 어떻게 돌아가는지 설명해 드린 뒤
         최종적으로 괜찮다 고 하면 System Requirement를 확정짓는 과정임. 
      >> 실제 Business System의 경우, 다같이 문제를 분석해 해결하는것보다도, 여러개의 팀에 의해 나눠져 개발되는 경우가 만하. 
         여러 팀에 의해서 개발되다 보니 Requirement가 계속해서 바뀌게 된다.(Agile이다 보니, 안맞으면 바꾼다고 가정을 해야 함!)
         (Change가 계속 발생하는 것이다) 
         
      >> 그렇기에, Agile에서는 그냥 User Story에 집중해 최대한 빨리 만드는 데 목표를 둔다. Customer와 합의한 내용을 쭉 개발자들에게 
         알려주고, "이 사람은 이런걸 원하는데 여기에 맞게끔 우리가 알아서 개발을 해야 돼!" 하는 것임.
      >> Spec를 디테일하게 만드는게 중요한 게 아니다. 만들어서 가져가 보고 오케이 나면 그 다음 진행하는 식임.
      >> Business System에 있어서는 이런 방법이 현실적이기는 하다. 문제를 해결하는 System 같은 경우에는 Delivery-Analysis같은 것들이 필요
         한데, Business System의 경우에는, 미리 한번 만들어 보여줘서 분석을 하는 방식이다. 
         
   < Spec이 이런 식으로 작성되고, 구성되고, 진행된다, 만들어진다. 라는 것을 개략적으로 파악하면 된다고 한다. 생각만큼 딱딱 정해져서 개발하는
     것이 아니다! 라는 것임 >
     (Spec을 어느 정도 Detail하게 구성을 하되, 너무 거기에 시간을 쏟지는 말자. 실제로 개발해서 보여줬을 때 고객이 느끼는 체감은 어차피
     다를 것이다. )(그냥 어느 방법(Agile vs Waterfall)에서 어디에 치중을 두어 개발할지 선택해 진행하면 된다)
     
    
    
  ** Functional and Non-Functional Requirements
    
      >> Spec 안에는, Functional / Non-Functional / Domain Requirements 3가지가 꼭 포함이 되어야 함. 
        (경우에 따라서는 Non-Functional 이나 Domain Requirement들은 빠져 있을 수도 있음)
      
      >> 대부분 학생들에게 Requirement 작성하라고 하면, Functional Requirement만 작성하고 끝난다. 
      >> 로그인이 1초 이내로 완료되어야 한다 와 같은 내용의 Requirement는 생각을 안 한다. 로그인하는데 5~10초 걸리면 누가쓰겠는가?)
          -> 이런 내용들이 Non-Functional에 해당된다!    
      >> 특성,성능, 퍼포먼스 같은 특성들은 모두 Non-Functional Requirement에 해당되고, 프로그램의 제약사항에 포함됨.
         ex) System이 하루종일 24시간 동작해야한다 같은 것들도, Non-Functional Requirement에 해당되는 것이다
         ex2) 프로그램 잘 돌다가, 1시간 만에 발열 이슈로 다운되면 안되는 것도 Non-Functional Requirement!
         
      >> Functioanl Requirement는 이미 다 잘 아는 내용. (어떤 동작을 해야 하는지, 어떤 행위를 해야 하는지 등)
      >> Functional 제외하고는 거의다 Non-Functional이라고 생각하면 된다. 
      
      >> Domain-Requirement
          -> 사용자나 사용되는 환경에 특화된 Requirement가 Domain-Requirement이다.
           ex: 학교에서 사용되는 프로그램과, 군대에서 사용되는 프로그램은 그 형태나 모습이 많이 다를 것이다.
           (똑같은 프로그램이라도, 군대로 들어가는 순간 외부 인터넷과 연결이 되어서는 안된다)-> Domain Requirement
           
           ex2: 의료분야에서, Software에서 환자들의 개인정보는 인가받은 사람만 열람해야 한다 -> Domain Requirement
           
           
     
     *** Functional Requirements 
       >> Functional Requirement나 System service에 대해 기술
       >> 어떠한 사용자가 쓸 것인지, 어디서 쓸 건지와 같은 것들로 Requirement가 많이 작성이 된다. 
       >> 굉장히 높은(최상화된) Level에서 이루어진다. 
       >> 디테일하게 써줘야함.(시스템이 어떻게 동작하는지는 덜 추상적인데, 서비스 같은 경우에는 "~한 서비스를 만들 것이다" 와 같은
          추상화된 내용으로 많이 나온다. 최대한 디테일하게 서비스에 대해 작성해주는 것이 좋다.)
           ex) (Mentcare System : functional Requirements)
            - 유저는 병원에서의 예약내역을 볼 수 있어야 한다. 
       
     *** Requirement Imprecision (Requirement가 부정확할 때, 애매모호할때 생기는 문제들)
       >> Functional Requirement가 부정확하면, 애매한 Requirement가 된다. 
       >> 애매하게 쓰면, 중의적인 표현이 있을 수 있고, 그런 중의적인 표현같은 경우 정확히 해석이 안되는 경우가 있음.
       >> 개발자가 해석한 내용과, 사용자나 Requirement를 제공한 사람들/서비스를 이용하는 사람들이 받아들인 내용이 다 달라진다
       ex) Search : 
           - 유저가 의도한 것 : 환자 이름을 넣었을 때, 그 환자와 관련된 모든 진료내역이 나와야 한다(모든 병원에 있어서)
           - 개발자가 이해한 것 : 환자 이름을 넣었을 때, 그 환자가 병원에서 받은 모든 진료내역이 나와야 한다(그냥 그 해당병원에서)
                                  (병원마다 다 따로 검색이 됨)(이렇게하면, 개발자가 개발하기 더 쉬움)
           -> "모든 진료내역이 나와야한다!" 라는 내용이 어느 스케일에서 진료내역인지 확실하지 않고, 중의적이다. 
           -> 그냥 "모든 진료내역" 이라고 했으니, 개발자가 이해한 것도 아예 틀린 이야기는 아니다. 
           
         
     *** Requirements Completeness and Consistency (Requirement는 완결성이 있어야 하고 한결같아야한다!)
       >> Completeness : 모든 Requirement 항목에 그에 상응하는 설명이 있어야 한다!
           -> 모든 기능 설명에서 모르는 단어나 시스템이 있으면 안된다. 
           -> 필요한 것들은 싹다 명시를 해줘야한다! + 설명 안에서도 어떤 동작에 대해 필요한 설명들에 대해서는 언급이 반드시 되어야 함.
           
       >> Consistency : Requirement 안에 충돌이나 모순되는 내용이 없어야 한다. 
           ex) Requirement 두개가 있는데, 두 항목이 서로 절대로 같이 일어날 수 없는 Requirement가 있을 수 있다. 이런 경우에는 
               둘중에 하나를 바꿔야 한다. 
               
       >> Requirement 작성할 때 단순히 작성했다고 끝나는 것이 아니라, 내가 정확하게 다 기술했는지, 필요한 것들이 모두 나열되어 있
          는지, 나열한 것에서 충돌이나 모순되는 부분은 없는지 꼼꼼히 확인해야 한다. 이런것들이 다 꼼꼼하게 확인이 되어야,
          "Requirement 로써 유효하다" 라고 할 수 있는 것이다. 
          
       >> 실제로 하다보면, 기능적으로 Requirement 짜놓고 보았을 때는 아무 문제가 없는데, 실제로 설치되어 사용할 곳을 가보니
          설치되어 사용될 환경과 맞지 않는 것이 있을 수도 있음. 
            ex) 어떤 장비를 설치하러 갔는데, 설치할 곳이 경사가 있음. 삐딱하게 세울 수밖에 없는 곳. 하지만 카메라를 해당 환경에
                설치를 할때는, 삐딱하게 볼 수 밖에 없는 환경임. 하지만, 카메라 시야가 0도~180도 사이라고 가정해버리면, 해당 
                Requirement를 만족시킬 수가 없는 것이다. 
                
            -> 보통은 어떤 시스템을 만들 때, 그 대상을 아주 일반적이고 흔히 아는 환경에 대해서만 생각한다. 
                ex) 기차를 탈 때 모든 경로를 직선으로 생각한다던지 / 자율주행 자동차가 달리는 도로가 모두 환경이 좋은 길로만 생각한다던지
                
            -> 이런 환경에 대해서도 반드시 고려해야 할 대상 중 하나이다!!     
            
     *** Non-Functional Requirements 
       >> Reliability(신뢰성) : 시스템을 신뢰할 수 있는가? (아래의 요건을 만족시키는 것을 보고 Reliability라고 한다)
            -> 시스템에서 서비스를 제공할 때, 이 서비스를 사용자가 원하는 시간대에, 어떤 요청을 보냈을 때 언제든지 믿을 수 있는 
               결과를 제공하는가? (중간에 서버 안뻗고)
            -> 언제든지 사용자가 이용하고 싶을 때 이용 가능하고, 돌아오는 결과값이 믿을 수 있는 결과를 받아야 한다. 
            -> 서비스가 꾸준하게, 언제든지 잘 이루어질 수 있도록 하는 것.
             ex) 은행이 9시 반~3시 반까지 하는데, 최소한 그 사이 시간대에 은행을 가면 언제든지 은행문이 열려 있어야 함!
                 (물론 그 시간이 아니면 서비스를 받지 못할 것임)
                 - 사용자는 최소한 그 시간대에 방문했을 때 언제든지 서비스받을 수 있다는 생각을 가질 것임. 
                 - 만약, 10번 중 한번은 해당 은행에 감사가 나와서 3시 반이 아닌 3시에 마감했으면, reliability = 90% 가 될 것이다. 
                   (10번 중 1번은 이용하지 못했기 때문)
             
             -> 사용자가 서비스를 제공받는데, 실제로 이 시스템을 사용하려 할 때 서비스를 제공받을 수 있었는가? 의 관점이다. 
       
       >> Response Time / Storage Requirement 도 다 Non-Functional Requirement 에 포함되는 것이다. 
       >> 위의 두개가 "기능"이라고 볼 수 있지 않는가? : "기능"은, 말 그대로 "어떤 것을 할 수 있냐 없냐"의 문제임. 
          "기능이 좋다" 라고 하는것은 생각해보면 다 Non-Functional이다. 퍼포먼스와 같은 것.
          
       >> Process Requirement 라는 것도 존재한다! 
             -> IDE / Programming Language / Development Method 같은 것들도 하나의 Requirement로 볼 수 있는 것이다. 
               ex) 해당 시스템 개발할 때, Visual Studio로 개발해 주세요! 같은 것들이 있을 수 있다. 이런 경우는 해당 소스코드까지
                   고객이 다 가져가겠다는 의미. ( 일부 파트를 외주로 줘서 개발을 하는데, 자기네 회사에서 개발한 환경과 똑같이 만들어
                   주세요! 하는 case. 그래야 그것을 고대로 복사해서 그 회사 컴퓨터에 깔면 바로 작업할 수 있을 것임.)
                   
       >> Non-Functional 과 Functional을 비교할 때, 둘중 "만족되지 않았을 때" 문제가 커지는 것은? : Non-Functional이다!
             -> Functional은 그냥 안되면, 해당 부분이 빠졌다고 이야기하고, 나중에 거의 다 구현할 수는 있는 애들이다
             -> Non-Functional은 만족이 안되면, 크게 구조를 다 갈아엎는 경우가 굉장히 많다. 지금 상태의 코드에서 아무리 고쳐도
                Non-Functional 부분이 만족이 안되면, 해당 알고리즘을 통째로 바꿔야 함!
                ex) Sorting에서 Bubble Sort로 짰는데, 무슨수를 써서도 거기서 속도가 더 안올라가면, Sorting 알고리즘을 아예 바꿔야 함
                
                 
             
         
    
    
