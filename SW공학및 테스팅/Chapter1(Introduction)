## 소프트웨어공학 및 테스팅 이론정리(2022.03.03~) ##

< 1장 : Introduction >

* 테스팅이라는 이론은 왜 나왔는가?
-> 이때동안은 빠르게 잘 만드는 것만 해도 괜찮았다! 만드는 것에 굉장히 초점이 많이 맞춰져 있었다. 
-> 그러다 보니, 안전에 관련된 소프트웨어에서(ex:테슬라의 오토파일럿 등) 많은 사고들이 발생을 하더라!
-> 그런 연유에서, 개발이 빨리 이루어지는 만큼 테스팅도 그에 따라 개발이 발전하는 속도에 맞춰 연구가 되고 있었다. 

@@-> 개발에서 잘못 되어 있는 것을 테스팅에서 잡아내지 못한다면, 큰 문제가 될 수 있다. 안전에 관련된 소프트웨어인데 이런 미스가 난다면
     개인의 안전과 재산상의 피해가 많이 발생할 것이다! 그렇기에 테스팅은 아주 중요하다.
     
*** 그렇기에, 항상 만들때는 테스팅할 것을 생각하면서 만드는 자세가 중요하다. (만드는 것도 중요하지만, 테스팅하는 것도 중요한 문제이기 때문) ***
ex) 임베디드 소프트웨어를 만들 때, 선에 표시 하나도 안해 놓고 이 선 저 것 다 결합해서 만들다가 문제가 생기면, 어느 선이 어떻게 연결되어 있는지 몰라
    상당히 애로사항이 발생할 것이다. 
    
*** 소프트웨어 공학에 있어서, 개발을 어떤 식으로 진행하는지 / 윤리적인 내용 & 그에 따른 여러가지 이슈들 / 여러가지 케이스들(실제사례) 같은 것들을 다룬다 ***

** 소프트웨어 코스트(Software Cost) : 단순히 어떤 소프트웨어를 개발하는 데 필요한 비용뿐 아니라, 이것을 개발하기 위해서 필요한 제반 사항들까지 모두 포함한 비용이다!
ex) 아이폰 - 부품, 원자재값 + 디자인을 만들고 기획하고 설계하고 양산하는 그런 제반사항들까지 모두 포함한 비용!

** 소프트웨어 프로젝트는 왜 가끔 가다 실패를 하는가?

-> 시스템 복잡도가 올라가는 사례 - 사용자가 단순히 이것 해달라, 저것도 넣어달라, 그것도 넣어달라 하다가 구조적으로 프로그램이 엉망이 되어 버리는 케이스. 
                                  단순하게는 지금 txt, binary, csv파일로 점점 올라가다가 실시간 처리를 요구하게 되는 그런 상황이었지만, 이것보다 더 고차원 적인 것을
                                  구현하다가 이런 식으로 엉망이 되어 버린다면 급기야 손을 댈 수도 없는 상황이 만들어질 수 있다. 너무 시스템 복잡도가 올라갔기 때문.
                                  
                                - 과감하게 싹 버리고 새로 짜는 것이 방법이 될 수 있다. 이미 해당 코드를 짜면서 생각해 놓은 부분들이 있기 때문에, 다음에 짜면 조금 더 
                                  구조적으로 더 잘 짤수밖에 없다. 그렇기에, 생겼던 문제들을 좀 생각하면서 짜는 것이라 좀 더 나은 결과물이 나오게 된다.   


-> 소프트웨어 개발 방법(론)이    - 개발 방법(론)이 무조건적으로 어떠한 방식으로 개발하야 된다 라는 것은 없다! 기본적으로 "이런 종류의 SW는 이렇게 만드는 것이 좋다!" 라는 
   해당 소프트웨어 개발 케이스에   사례들이 있긴 함. 하지만 그게 만능이고, 무조건 정답이라는 것은 아니다. 무조건 정답이 아닌데도 불구하고 해당 기법으로 소프트웨어를 개발하려고
   맞지 않은 사례                 고집을 부리다 보면, 이도저도 아닌 상황이 벌어지고 시간을 못 맞추거나 기능적으로 동작을 잘 하지 못하는 등의 사례가 발생할 수 있다. 
                                   
                                   ex) WaterFall 방법론 : 많은 시간이 걸린다. 하지만 한달짜리 프로젝트에 해당 방법론을 들고 오다보면 절대로 가능할 수 없는 것이다. 
                                                          다른 개발 방법론에서 여기에 맞게끔 변형을 하던지, 아니면 어떤 시스템을 바꿔서 변형을 하는 등의 결단이 필요하다. 
                                                          정답은, 해당 개발에 맞는 솔루션을 만들어 내야 하는 것이다!!
                                                          
                                                          
 * Professional Software Development *
 
 ** Software Engineering에서 자주 질문되는 것들 ! :
 
  -> 소프트웨어란 무엇인가? :  단순히 컴퓨터 프로그램으로 끝나지 않는다. 여기에 추가로 관련 소프트웨어 문서가 들어간다!(Like 사용자 메뉴얼)
                              관련된 문서들이 단순히 고객을 위해서 존재하는 것 뿐만은 아니다. 개발자 본인들이, 자기가 만든 소프트웨어 구조를 잊어버릴 수도 있고,
                              애초에 다같이 협업해서 만들었을 수도 있다. 이럴 때를 대비해서 과거의 본인 또는 동료들이 작성했던 문서들을 확인하면서 고쳐야 할 것이다. 
                              문서를 확인하면 소프트웨어의 구조를 알 수 있을 것이고, 어떻게 고쳐야 할지 방향을 잡을 수 있기 때문이다. 
                              
                              하지만, 무조건적으로 문서화만 해서는 안 될 것이다. 문서화 하라고 하여 1부터 10까지 다 일일이 적고 있으면 개발이 진척이 안 될 것이다. 
                              손은 언제나 한정적이게 되어 있다. 비중을 적절히, 요구도에 따라 조절을 해야 한다. 
                              물론, 하나부터 열까지 다 기록하는것이 제일 좋고, 문제 생길 소지도 제일 적다. 하지만, 그만큼 시간도, 힘도 많이 들고 해야 할 일이 많음.
                              인력이 더 필요한 것이다. 
                              
  -> Software vs Software Product :  Software Product는, 그것을 쓰고자 하는(쓸 수도 있는) 사람이나 그룹을 위해 만들어 질 수 있는 Software를 말한다. (맥락을 이해하자!)
  
  -> 소프트웨어 공학이 추구하는 방향? : 좋은 소프트웨어를 만드는 것. 좋은 소프트웨어는 어떤 것을 가지고 있는가 하는가? 를 알고 추구하는 것.
                                       Required Functionality and Performance "To the User". 개발자에게 좋고, 개발자가 만들기 쉽고, 잘 쓰기 쉬운 것이 아니라 
                                       개발자가 만들어서 누군가에게 쓰라고 만들어 주는 것이다! 
                                       그러므로, 쓰는 사람에게 편해야 하고, 잘 동작해야 하며, 이 사람에게 좋은 성능을 내야 하는 것이다. 이것이 제일 중요함!
                                           
                                       결국 모든 측면을 봐야 한다! 소프트웨어를 생산하는 과정에 있어 필요한 모든 제반 사항을 다 알아야 할 필요가 있다~
                                           
  ->SW Engineering vs Computer Science 차이? : 컴퓨터 전반의 지식(필요한 하드웨어, 동작하는 과정이나 방식 등) 을 보고 Computer Science라 하고,
                                                SW Engineering은 해당 "컴퓨터"를 동작시키는 Software를 만드는 데 필요한 여러 가지 개발 방식 등을 말하는 것.
                          
                          
  -> 개발 프로세스 활동 : Specification / Development / (Validation)(테스팅) / Evolution
                          
                          Specification : 스펙 짜는 것. 소프트웨어를 만들 때, 이를 위해서 필요한 "스펙"들이 있을 것이다. 하드웨어 스펙은 어떤 수준까지 필요하며, 
                                          소프트웨어는 A에서 a라는 동작을 해야 하고, B에서 b라는 동작을 해야 한다 라는 등의 것을 정의하는 것을 Specification이라고
                                          한다. 
                                          
                          Development : Specification한 것들을 실제로 구현하는 일. 구현하기 위해서는 A라는 방식을 취해야 하고, n명이 필요하며, 누가 뭘 해야 되는지 
                                        정하고, 실제로 구현하는 것이 Development 과정이라고 생각하면 된다.
                                        
                          Validation : 잘 만들었으면, 잘 개발되었느지 확인하는 과정이 필요하다. 그냥 만들어놓고, 내가 잘 만들었다고 얘기할 수는 없다. 
                                       Software가 정확히 동작하는지 확인해야 하는 것임. Specification에서 정해져 있는 대로 잘 만들어졌느냐의 관점과,
                                       실제로 만들었지만, 정의되어 있지 않지만 기본적으로 들어가야 되는 사안들에 대해서도 잘 들어가있는지 확인하는 것.
                                       ex) 안드로이드 앱인데, 터치 식으로 입력이 아니면 곤란할 것이다. 추가적으로, 서버 단에서 처리해야 할 과정들을 
                                           사용자 인터페이스 단에서 처리하여 다른 앱보다 훨씬 더 많은 데이터를 소모하게 되는 것도 곤란할 것이다. 
                                           이런 기본적인? 사안들도 다 들어가 있는지, 그 전반적인 것도 확인이 필요하다.
                                           
                          Evolution : 여러 가지 이유로 (예 : 시간이 많이 흐르는 등)(옛날 정보라 업데이트가 필요하거나, 새로운 기술이 나와서 추가하는 등)
                                      추가적인 기능이나 데이터를 추가할 수도 있다. 반면에, 특정 기능은 이제 안 쓰는 기능이니 뺄 수도 있을 것이다.
                                      
                                      소프트웨어가 이런 작업으로 인해 "진화" 하는 것을 보고 Evolution이라고 함.
                                      
   *** -> 위의 4단계가 계속 반복되는 것이다! Evolution 단계를 마치고 나면, 다시 우리가 쓰고 있는 소프트웨어에서 더 필요한 게 있는지 Specification 하게 된다..
          그렇게 되면 다시 Development를 거치며, Validation 단계를 필요로 할 것이다. 그리고 다시 업데이트 한다. (Like 카카오톡 어플리케이션)
  
  -> SW Engineering에서 요구되는 Key Challenging : 다들 원하는 게 다르고 해달라는 것은 많은데 시간은 없다! 개발하는데 절대적인 시간이 많이 부족하다. 
                                                   굉장히 빨리 개발하는게 중요함. 그러다 보니 Framework도 많이 생기고, 플랫폼 기반의 Application을 개발하는 이유가 
                                                   되기도 한다. (남들이 다 API 개발해 놓아서 편하다!)
                          
  -> SW Engineering 에서의 Cost : 개발 60%, 테스팅 40%. 덩치가 더 커지면 커질수록 테스팅 비용이 엄청나게 증가해서 더 그렇다. 
  
  
 ** SW Product의 종류 두가지 :
   -> General Product : 거의 전부 다. 구글 플레이에 들어가서 설치하는 앱들은, 고객층을 그냥 노리고 만든 앱이다. 꼭 누가 만들어달라고 부탁해서 만든 앱이 아니라, 
                        누가 쓸지는 모르지만 "이런 걸 만들었으니 잘 써 봐!" 하고 만든 것임. 
                        
   -> Customized Product : 특정 고객이 "어떤 것이 필요하다" 라는 요청을 하면, 그대로 만들어 주는 것. 
                              
    *** 이 두가지 소프트웨어를 만드는 방식이 당연히 같을 수가 없다! 그리고 두 가지 소프트웨어의 특성, 특징 또한 다 다를 것이다!
        막상 시대의 흐름을 따라 만든것이 잘 안될수도 있고, 그냥 막상 만들었는데 잘 될 수도 있는 것이 General Product의 특징이다. 
        반면 Coustomized Product는 고객의 요청에 따라 만드는 것이라, 쉬울 수도 있다.(물론 고객이 까탈스러운 사람이라면 힘들 수도 있겠지만)
        고객이 속내를 잘 내보이는 사람이라면, 꼬치꼬치 캐물어가며 만들 수도 있을 것이다. 하지만, 고객이 그런 것 없이 빙빙 돌리는 사람이라면
        개발자가 정리해서 설득시켜야 할 수도 있다.
        
 ** 좋은 소프트웨어를 개발하기 위해 필수적으로 해야 할 것들
    -> Maintainability / Dependability & Security / Efficiency / Acceptability
    
    -> Maintainability(유지보수) : 유지보수를 얼마나 잘 할 수 있는가?! 에 대한 것. 
                                   수정, 삭제, 기능추가 3가지를 보고 유지보수라고 한다. 이 3가지를 잘 할 수 있게 만들어야 할 것이다.
                                   물론 이 3가지를 적절히 잘 수행해야 하는것도 포함.
    
    -> Dependability : 어떤 "컴퓨터"에서 돌려도 잘 동작해야 한다는 것! 
    
    -> Efficiency(효율성) : 얼마나 해당 소프트웨어가 유저에게 맞게끔 만드냐?! 얼마나 적은 힘을 들여서, 편리하게 잘 사용할 수 있는가? 하는 것.
    
    -> Acceptability : 해당 프로그램이 수용이 가능한 정도. 완벽하게 해당 요건을 만족하지는 못했지만, 이 정도면 "수용 가능하다!" 한다면 사용할 
                       수도 있을 것이다. 
        
  
  ** Software Engineering (초기 스펙잡고 만들때부터, 사후 관리까지가 모두 포함된 Engineering 규칙이다!)
     
     -> Production의 관점에서 봐야 함!
          >> Software가 하나의 상품이라고 생각하고 접근하는 것이다. 
          >> 상품을 만들 때 "어떤 상품을 어떻게 만들지" 고민하는 것처럼, "어떻게 사용자에 맞게끔 좋은 소프트웨어를 만들 수 있는가" 라는 것을
               고민해야 함. 구상하는 단계부터 경제적인 부분까지 싹다!
     
     -> 소프트웨어를 만들 때 어떤 활동들이 있는가?
          >> Specification 
               ( 스펙 정의, 우리가 만들려고 하는 상품이 "어떤 것이어야 한다" 라는 것을 정의함 
                 스펙을 얼마나 구체적으로 작성하느냐가, 나중에 결과물에 많이 반영될 것이다.
                 하지만, 너무 상세하게 해 버리면, 나중에 구현이 안되는 "모순적"인 스펙이 생길 수 있다.
                 약간은, 추상적인 범위를 열어두는 것도 좋다!)
          >> Development 
               ( 스펙에 정의된 것들을 어떻게 달성할 것인지 정하고, 만드는 것. 개발자의 성향에 따라 방식이 달라질 것임. 
                 구현하는 방법적인 부분은, 나중에 evolution 때 보완할 수도 있음. 당장 되는 방법으로 하면 된다. )
          >> Validation
               (스펙과 개발이 얼마나 일치하는가를 보는 것! 사용자가 원하는 소프트웨어에 대한 것과, 실제로 만들어 놓은 것을 비교한다. 
                기본적으로 스펙과, 개발된 소프트웨어가 동일해야 되는 것이다! 이것을 체크하는 것을 보고 "Verification" 이라고 한다. 
                "Verification"을 "Validation"과 동일하게 보는 시각도 있고, "Verification"을 "Validation"에 포함되는 개념으로 보는 시각도 
                있다. "Verification and Validation"(VMV) 라고 한방에 부르는 사람들도 있다.
                어쨌든, 소프트웨어가 얼마나 잘 만들어졌는가 라는 것을 확인한다는 것임! 확인하는 기준은 Spec이 될수도, 사용자가 
                될수도 있다. 이 스펙도, General Software인지 Customized Software인지에 따라 다를 것이다.
                Customized Software의 경우, 고객이 "이렇게이렇게 만들어주세요!" 한 것을 개발자가 이해해서 Spec을 정의한 후 
                해당 스펙과 비교하는것 뿐만 아니라, 사용자가 실제로 요구했던 요구 사항과 일치하는지 확인하는 단계까지가 Validation이다!)
          >> Evolution
               ( Software가 출시되고, 그 이후 여러 가지 필요성들로 인해 몇몇 부분을 Changing 하는 것을 말함. 최신 기술로 업데이트 해서 
                 새로 배포할 수도 있고, 새로운 정보, 새로운 Market 환경으로 인해 해당 부분을 Update할 수도 있다. 
                 시대상황이 워낙 빨리 변하다 보니, 대체로 Evolution도 위의 활동 내용에 포함된다. )
          
  ** Software에 적용되는 General Issue
     
     -> Heterogeneity
          >> 개발자가 만든 Software가 하나의 디바이스에서만 동작해서는 안된다!
          >> 물론 Hardware-Dependent(ex: Embedded Software) 같은 경우도 잇지만, 일반적으로 Software라고 하는 것은 Hardware에 크게 
             구애받지 않는 Software라고 생각하면 된다. 
          >> 집에 있는 컴퓨터로도, 친구 집에 있는 컴퓨터로도 똑같이 해당 프로그램이 실행되어야 하며, 스마트폰도 같은 경우에
             똑같이 잘 실행되어야 한다! 어떤 디바이스든지 구애받으면 안된다!
     
     -> Business와 사회적 변화
          >> 고객 타겟팅이 바뀌는 경우. Model이 바뀌는 경우에는, 해당 Software를 판매하고자 하는 대상들이 바뀌어서 그런 경우가 많다. 
          >> 사회적 변화의 경우, 동일한 대상이라 할지라도, 그 대상이 가지는 특성이 달라져 버리기 때문에 Software를 바꿔야 할 수 있다.
             ex) 지금 20대와 10년 전 20대는 같은 20대지만, 사회적으로 지금 20대와 10년전 20대는 다른 사람들이다!
             해당되는 Change에 맞게끔 개발을 계속해서 해야 한다!
     
     -> 보안 & 신뢰성
          >> 사용자들의 정보 같은 것을 털리지 않기 위해서라도 보안은 아주 중요하며, 믿을 수 있는 소프트웨어 여야 한다는 것 역시
             중요함. 악의적인 목적으로 개발된 Software이면 안 될 것이다.
             
     -> Scale
          >> Galaxy Watch에 들어가는 Software 와 Smartphone에 들어가는 Software는 똑같은 앱이라도 조금 다르게 만들어져야 한다. 
             ex) Watch에 들어가는 카카오톡은 조금 더 가볍게 동작해야 할 것이다. 기존 카카오톡 앱에 여러 가지 기능들이 있지만
                 거기 있는 모든 기능들을 Watch에서 사용하기에는 무리가 있다. 기존 카카오톡 앱의 규모를 줄이고, 늘리고 하는 것도 
                 가능해야 한다!
                 
        
  ** Software engineering diversity
     
     -> Customer vs Background
          >> 결국 우리가 만드는 Software는 Customer가 사용하게 된다.(General Software도 마찬가지)
          >> Customer가 가지고있는 "Background", 개발자가 가지고 있는 "Background"에 따라 소프트웨어가 다르게 동작할 수 있다. 
             (background : 기저에 가지고 있는 생각)
             ex) 개발자는 자기 만들기 쉬운대로 만드는데, 사용자가 생각하는 것과 달라서 사용자가 새로 해당 부분을 고쳐달라고 하는 등
             
   
  ** Software의 종류 
  
     -> Stand-alone
          >> 혼자 서 있다. 지금 우리 시대 기준으로 봤을 때는, IT, 인터넷 이런것 없이 혼자 오롯이 기능할수 있는 Software
             통신적인, 외부 Component, 시스템 객체 같은 것들이 필요 없이 프로그램 자체적으로, 설치된 것만 이용해서 동작하는 Program
             ex) Microsoft Word. 설치만 되어 있으면 사용할 수 있음!
          >> Smartphone에서 사용되는 대부분의 앱들은 Stand-alone이 아니다! LTE 없이 안돌아가는것이 태반임. 
             Smartphone 또한 우리가 사용하는 노트북보다 성능이 낮은 사양이 "컴퓨터" 이다 보니, 최대한 일을 적게 하는 방향으로 
             앱들이 기능해야 한다. 
          
          >> 장점 : 설치해 놓고 나면, 다른 Component들이 없으니 쓰기 좋다. 
          >> 단점 : 필요한 모든 것들을 구현해야 한다. 하나하나 다 설치해서 동작하게끔 해줘야 한다. 
     
     -> Interactive Transaction
          >>  상호작용 하는 통신으로 동작하는 Software. 
          >>  ex) Remote computer, 다른 PC의 terminal을 사용하여 동작함. 우리가 사용하는 스마트폰에서의 앱이 여기 해당할 수 있다. 
          >>  ex2) E-commerce. 결제를 시도할 때, 결제 정보가 사용자의 PC나 Smartphone에 있는 것이 아니다. 
                   카드회사나, 금융사에 해당 정보가 있다. 결제를 하려면 해당 회사의 시스템과 연동되어, 데이터 확인 이후 결제가 
                   이루어지는 대부분이 웹 기반의 Application일 것이다. 
          
     -> Embedded Control System
          >> 위에서 말한 Software보다, 조금 더 큰 범주에서의 Software이다. 
          >> ex) 가정에서의 냉장고, 에어컨, TV, 세탁기 등의 Software
          >> Hardware에 내장되어 있는 System이다!
          
     ( 해당 3가지를 개발하는 방식이 다 다르다! )
     
     -> Batch Processing
          >> Batch : 일괄처리, 하나로 뭉쳐서 동작하는, 한방에 모든 것을 모아 동작하는 이라는 의미.
          >> ex) Web상에서 서류를 제출하는 등의 처리를 할 때, 똑같은 작업을 수행해야 하는 것들이 있음. 
          >> 대체로 몰아서 한방에 하는 Processing이 "Batch Processing" 이다!
          
     -> Entertainment System :
          >> 말 그대로 사용자들을 즐겁게 해주는 Software
          
     -> Modeling이나 Simulation을 위한 System :
          >> 수학적인 내용에 가깝다. 수학이나 물리 엔진 등의 라이브러리를 가지고 시스템을 구성해야 함. 
          >> 개발자 본인이 만드는 것 보다 이미 만들어진 것들을 호라용하는 것이 좋다. 과학적 모델링된 
             자료들은 이미 있는 것을 쓰는것이 좋다.  일일이 개발하고 구현해 확인하는 시간만 엄청나게 걸리는데
             이렇게까지 할 필요가 없는 것이다. 그냥 잘 만들어진 모듈이나 시뮬레이션 결과를 활용하면 좋다. 
          
     -> Data 수집하는 System :
          >> 말 그대로 Data를 수집하는 System
          
     -> Systems of System :
          >> 우리가 흔히 System이라고 부르는 것들을 말한다. System 간의 연결 같은 것들을 다루는 Software
             같은 것들을 말한다. 
          ( 번외 : 있는 System들을 보고, 이들 간의 유기적인 관계를 만들어내는 것도 굉장히 중요한 역할 중 하나이다.)
          
              
** Internet(Web) Software Engineering
     -> 웹 서비스의 시작 : 군사용으로 만들어진 "Alphanet"이 오픈된 것으로 시작되었다.
     -> WWW(World Wide Web) : 처음에는 단순히 정보를 공유하는 장소에서 시작되어, 메일, 유튜브 등으로 컨텐츠, 서비스가 
                              확장되었다. 그러다 보니 웹이 "플랫폼" 이 되기 시작함. 
                              
     -> Software(code) Reuse : 이제는 Reuse를 하지 않으면 개발하기 상당히 힘든 시대가 다가왔다. 우리가 하려는 기능이 
                               지금은 굉장히 많은 코드를 가지고 있는 내용이고, 이미 나와있는 것들을 사용하는 쪽이 생산성이
                               더 높기에, Reuse는 이제 피할 수 없는 일이 되어 버린 것이다. 
                               하지만, Reuse 했으면, Evolution까지 해야 한다! Reuse만 하게 되면, 그냥 원래 있던 프로그램 쓰는
                               것과 다를바가 없다. 만들고자 하는 개발자가 거기서 수정하고, 더 개발을 해야 된다는 것이다. 
                               그렇게 하려면, 만든 사람보다 더 잘 알아야 하긴 함. 
                               
     -> Incremental & Agile 개발 방법론 : 요즘 대세인 개발 방법론. 
          >> Incremental 방법론 : 단계별로 개발하는 것. "개발에도 단계가 있다!"
                ex) 중요 기능이 3가지 있으면, 기능 1만 개발하고 바로 출시한 후, 나중에 2를 추가로 개발한 후 Version2,
                    나중에 기능 3까지 넣어서 완전판으로 만드는 것임. 스마트폰에 앱 깔면, 설치 후에도 업데이트 엄청 많이 한다. 
                    그런 경우임. 
                    
          >> Agile 방법론 : 매일마다 하나의 프로그램을 만들어내는 것. 하루 만에 서비스 하나, 아니면 기능 하나라도 만들어내는 식. 
                            하루 단위가 아니라 일주일 단위여도 마찬가지. 
                    
      
      
      -> Service-Oriented System : 
          >> 기존에 개발할 때는, "여기에 무슨 버튼 넣고, 저기에 저 기능 넣고~" 라는 생각을 가지고 개발을 진행했다.
          >> Service-Oriented 적인 사고 (ex) :
               "~~  하는 서비스를 제공하는 채팅 프로그램을 만들 것이다. 이 채팅 프로그램을 사용하면, 사용자와 고객, 물건 파는 사람을
               매칭시켜 주어, 고객이 물건을 구매하면, 구매한 물건이 고객 손에 갈 때까지 채팅으로 그 물건에 대한 정보를 주며 끝까지 
               책임지는 서비스를 제공할 것이다!" 
          >> 해당 프로그램의 형태가 어떻게 되든, 모양이 어떻게 생겼든 상관이 없는 것임. 어떤 형태가 되던지 간에 그 서비스를 달성할 
             수 있는 목표만 이루어낼 수 있으면, 소프트웨어는 어떤 형태가 되던지 상관이 없는 것임.
          >> 창, 버튼, 레이아웃 같은 것은 부수적인 내용들이 되는 것이다.     
               
               
       -> Rich Interface : 말 그대로 Interface가 풍부하여 선택지가 다양하다는 이야기. 
              ex) Embedded System을 만들 때는 C나 C++ 로밖에 제작할 수 없지만, 웹 같은 경우에는 C, Java, Python, JS 등 많은
                  인터페이스가 있다는 것. 
              
                
** Software Engineering Ethics
     
     -> 특허(Copyright) 조심해야 한다! 
          >> 프로그램도 저작권이 있는 것.
          >> 오픈소스를 사용할 때에도, License를 잘 확인하고 사용하는 것이 좋다. 
          >> 자기 것을 공개하는 것과, 공개되었다고 해서 그냥 갖다쓰는 것은 다른 문제다. 
     
     -> Software를 만들었을 때 나타나는 오류들을 잘 해결해 주어야 한다. 
          >> 사용하다 보면 어떤 일이 벌어질 지 모름. 개발자가 의도한 대로 사용하지 않고, 사용자가 맘대로 사용하는 경우가 있는데,
             이럴 때 나타나는 에러들도 다 해결을 해 줘야 한다!
          >> Misuse로 인해 나타나는 것 중에는 보안과 직결되어 치명적인 것이 나타날 수도 있으니 특히 유의해야 한다. 
     
     -> 개인정보 처리에 대해서 유의해야 한다!
     -> 나머지 윤리적인 부분들은 다 상식선 안에서 해결하면 된다!
      
      <<뒤에는 그냥 보면 되는 예시>>
            
        
        
        
